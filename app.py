"""
Income Wheel - Streamlit Application
Main entry point for the Options Income Wheel tracker
"""
import streamlit as st
import pandas as pd
from datetime import datetime, date, timedelta
from pathlib import Path

# Page config must be first Streamlit command
# Note: Title will be updated dynamically based on portfolio selection
st.set_page_config(
    page_title="ARGUS",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

from config import TICKERS, WEEKLY_TARGET_PCT, EXPIRING_SOON_DTE
from excel_handler import ExcelHandler, validate_data_integrity


def get_tickers_for_dropdown(portfolio: str, df_trades=None):
    """Ticker list for this portfolio: saved tickers + tickers from positions. Income Wheel falls back to config TICKERS when saved is empty."""
    base = get_tickers(portfolio)
    if not base and portfolio == "Income Wheel":
        base = list(TICKERS)
    position_tickers = []
    if df_trades is not None and not df_trades.empty and 'Ticker' in df_trades.columns:
        position_tickers = df_trades['Ticker'].dropna().astype(str).str.strip().str.upper().unique().tolist()
    combined = [t for t in (base + position_tickers) if t]
    return sorted(set(combined))
from calculations import CapitalCalculator, PremiumCalculator, QuotaCalculator, RiskCalculator, CSPTankCalculator, PMCCCalculator
from models import TradeValidator, generate_trade_id, generate_audit_id
from price_feed import PriceFeed, display_price_status, get_cached_prices
from market_data import MarketDataService as _MarketDataService
_market_data = _MarketDataService()
from persistence import get_portfolio_deposit, save_portfolio_deposit, get_margin_percentages, save_margin_percentages, get_capital_allocation, save_capital_allocation, get_portfolio_deposit_sgd, save_portfolio_deposit_sgd, get_fx_rate, save_fx_rate, get_pmcc_tickers, save_pmcc_tickers, get_tickers, save_tickers
from ai_chat import render_ai_chat
from strategy_ui import render_strategy_instructions
from income_scanner_ui import render_income_scanner
from daily_report import render_daily_report_panel

# ============================================================
# FORMATTING HELPERS - Negative Values in Red with Parentheses
# ============================================================
def format_currency(value, decimals=2, show_cents=True):
    """
    Format currency value. Negative values shown as (-$xxx) in red.
    
    Args:
        value: Numeric value to format
        decimals: Number of decimal places
        show_cents: If False, rounds to whole dollars
    
    Returns:
        Formatted string with HTML styling for negative values
    """
    if pd.isna(value) or value is None:
        return "$0.00"
    
    value = float(value)
    
    if show_cents:
        if decimals == 0:
            formatted = f"${abs(value):,.0f}"
        else:
            formatted = f"${abs(value):,.{decimals}f}"
    else:
        formatted = f"${abs(value):,.0f}"
    
    if value < 0:
        return f'<span style="color: #ff4444;">(-{formatted})</span>'
    else:
        return formatted

def format_number(value, decimals=2):
    """
    Format number. Negative values shown as (-xxx) in red.
    
    Args:
        value: Numeric value to format
        decimals: Number of decimal places
    
    Returns:
        Formatted string with HTML styling for negative values
    """
    if pd.isna(value) or value is None:
        return "0"
    
    value = float(value)
    
    if decimals == 0:
        formatted = f"{abs(value):,.0f}"
    else:
        formatted = f"{abs(value):,.{decimals}f}"
    
    if value < 0:
        return f'<span style="color: #ff4444;">(-{formatted})</span>'
    else:
        return formatted

def format_percent(value, decimals=2):
    """
    Format percentage. Negative values shown as (-xx.xx%) in red.
    
    Args:
        value: Numeric value to format as percentage
        decimals: Number of decimal places
    
    Returns:
        Formatted string with HTML styling for negative values
    """
    if pd.isna(value) or value is None:
        return "0%"
    
    value = float(value)
    formatted = f"{abs(value):,.{decimals}f}%"
    
    if value < 0:
        return f'<span style="color: #ff4444;">(-{formatted})</span>'
    else:
        return formatted

def format_currency_for_display(value, decimals=2, show_cents=True):
    """
    Format currency for display in DataFrames, captions, etc.
    Negative values shown as (-$xxx) in red.
    Returns HTML string for use with st.markdown(..., unsafe_allow_html=True)
    """
    if pd.isna(value) or value is None:
        return "$0.00"
    
    value = float(value)
    
    if show_cents:
        if decimals == 0:
            formatted = f"${abs(value):,.0f}"
        else:
            formatted = f"${abs(value):,.{decimals}f}"
    else:
        formatted = f"${abs(value):,.0f}"
    
    if value < 0:
        return f'<span style="color: #ff4444;">(-{formatted})</span>'
    else:
        return formatted

def format_number_for_display(value, decimals=2):
    """
    Format number for display. Negative values shown as (-xxx) in red.
    Returns HTML string for use with st.markdown(..., unsafe_allow_html=True)
    """
    if pd.isna(value) or value is None:
        return "0"
    
    value = float(value)
    
    if decimals == 0:
        formatted = f"{abs(value):,.0f}"
    else:
        formatted = f"{abs(value):,.{decimals}f}"
    
    if value < 0:
        return f'<span style="color: #ff4444;">(-{formatted})</span>'
    else:
        return formatted

def st_metric_with_negatives(label, value, delta=None, delta_color="normal", help_text=None, decimals=2, is_currency=False, is_percent=False, suffix=""):
    """
    Display metric with negative values shown as (-xxx) in red.
    Same font size and alignment for positive (black) and negative (red).
    """
    if pd.isna(value) or value is None:
        value = 0.0
    
    value = float(value)
    
    # Format the value
    if is_currency:
        if decimals == 0:
            formatted = f"${abs(value):,.0f}"
        else:
            formatted = f"${abs(value):,.{decimals}f}"
    elif is_percent:
        formatted = f"{abs(value):,.{decimals}f}%"
    else:
        if decimals == 0:
            formatted = f"{abs(value):,.0f}"
        else:
            formatted = f"{abs(value):,.{decimals}f}"
    
    # Add suffix if provided
    if suffix:
        formatted = f"{formatted}{suffix}"
    
    # Same layout for both: one consistent font size and weight; only color differs (black vs red)
    value_style = "color: #0f172a; font-size: 1.25rem; font-weight: 600;"
    if value < 0:
        display_val = f"(-{formatted})"
        value_style = "color: #ff4444; font-size: 1.25rem; font-weight: 600;"
    else:
        display_val = formatted
    if label or help_text:
        st.markdown(f"**{label}**" + (f" ‚Äî {help_text}" if help_text else ""))
    st.markdown(f'<span style="{value_style}">{display_val}</span>', unsafe_allow_html=True)
    if delta is not None:
        st.caption(f"Œî {delta}")

def format_currency_for_dataframe(value, decimals=2, show_cents=True):
    """
    Format currency for DataFrame display (text only, no HTML).
    Negative values shown as (-$xxx) format.
    Handles both numeric values and already-formatted strings.
    """
    if pd.isna(value) or value is None:
        return "$0.00"
    
    # If value is already a string, try to extract numeric value
    if isinstance(value, str):
        # Remove currency symbols, commas, parentheses, and whitespace
        cleaned = value.replace('$', '').replace(',', '').replace('(', '').replace(')', '').strip()
        # Check if it's already formatted as negative (starts with - or has (-))
        is_negative = value.startswith('(-') or (cleaned.startswith('-'))
        try:
            value = float(cleaned)
            if is_negative:
                value = -abs(value)
        except (ValueError, AttributeError):
            # If we can't parse it, return as-is or default to 0
            return "$0.00"
    
    value = float(value)
    
    if show_cents:
        if decimals == 0:
            formatted = f"${abs(value):,.0f}"
        else:
            formatted = f"${abs(value):,.{decimals}f}"
    else:
        formatted = f"${abs(value):,.0f}"
    
    if value < 0:
        return f"(-{formatted})"
    else:
        return formatted

def format_number_for_dataframe(value, decimals=2):
    """
    Format number for DataFrame display (text only, no HTML).
    Negative values shown as (-xxx) format.
    Handles both numeric values and already-formatted strings.
    """
    if pd.isna(value) or value is None:
        return "0"
    
    # If value is already a string, try to extract numeric value
    if isinstance(value, str):
        # Remove commas, parentheses, and whitespace
        cleaned = value.replace(',', '').replace('(', '').replace(')', '').strip()
        # Check if it's already formatted as negative
        is_negative = value.startswith('(-') or (cleaned.startswith('-'))
        try:
            value = float(cleaned)
            if is_negative:
                value = -abs(value)
        except (ValueError, AttributeError):
            # If we can't parse it, return as-is or default to 0
            return "0"
    
    value = float(value)
    
    if decimals == 0:
        formatted = f"{abs(value):,.0f}"
    else:
        formatted = f"{abs(value):,.{decimals}f}"
    
    if value < 0:
        return f"(-{formatted})"
    else:
        return formatted

def style_dataframe_negatives(df, currency_columns=None, number_columns=None):
    """
    Style DataFrame to show negative values in red with parentheses.
    Returns a styled DataFrame that can be displayed with st.dataframe.
    
    Args:
        df: DataFrame to style
        currency_columns: List of column names that should be formatted as currency
        number_columns: List of column names that should be formatted as numbers
    
    Returns:
        Styled DataFrame with CSS applied
    """
    if currency_columns is None:
        currency_columns = []
    if number_columns is None:
        number_columns = []
    
    # Create a copy to avoid modifying original
    df_styled = df.copy()
    
    # Apply formatting to currency columns
    for col in currency_columns:
        if col in df_styled.columns:
            df_styled[col] = df_styled[col].apply(
                lambda x: format_currency_for_dataframe(x, decimals=0, show_cents=False) if pd.notna(x) else "$0"
            )
    
    # Apply formatting to number columns
    for col in number_columns:
        if col in df_styled.columns:
            df_styled[col] = df_styled[col].apply(
                lambda x: format_number_for_dataframe(x, decimals=2) if pd.notna(x) else "0"
            )
    
    # Apply CSS styling for negative values (red only, same size/weight as positive)
    def highlight_negatives(val):
        if isinstance(val, str) and val.startswith('(-'):
            return 'color: #ff4444;'
        return ''
    
    # Create styled DataFrame
    styled_df = df_styled.style.applymap(highlight_negatives, subset=currency_columns + number_columns)
    
    return styled_df

# Data file paths for different portfolios
INCOME_WHEEL_DATA_FILE = Path(__file__).parent / "data" / "income_wheel_data.xlsx"
ACTIVE_CORE_DATA_FILE = Path(__file__).parent / "data" / "Active Core.xlsx"  # Separate file for Active Core portfolio

# Get data file based on portfolio
def get_data_file(portfolio: str) -> Path:
    """Get the data file path for the selected portfolio"""
    if portfolio == "Active Core":
        return ACTIVE_CORE_DATA_FILE
    else:  # Income Wheel (default)
        return INCOME_WHEEL_DATA_FILE


# ============================================================
# SESSION STATE INITIALIZATION
# ============================================================
def init_session_state():
    """Initialize session state variables"""
    if 'data_loaded' not in st.session_state:
        st.session_state.data_loaded = False
    if 'df_trades' not in st.session_state:
        st.session_state.df_trades = None
    if 'df_audit' not in st.session_state:
        st.session_state.df_audit = None
    if 'df_open' not in st.session_state:
        st.session_state.df_open = None
    if 'live_prices' not in st.session_state:
        st.session_state.live_prices = {}
    if 'ibkr_connected' not in st.session_state:
        st.session_state.ibkr_connected = False


# ============================================================
# DATA LOADING
# ============================================================
@st.cache_data(ttl=60)
def load_data(portfolio: str = "Income Wheel"):
    """Load data from Excel with caching for the specified portfolio"""
    data_file = get_data_file(portfolio)
    
    if not data_file.exists():
        return None, None, [f"Data file not found for {portfolio}. Run migrate_data.py first."]
    
    handler = ExcelHandler(str(data_file))
    df_trades = handler.read_data_table()
    df_audit = handler.read_audit_table()
    
    # Validate integrity
    errors = validate_data_integrity(df_trades, df_audit)
    
    return df_trades, df_audit, errors


def refresh_data():
    """Force refresh data from Excel"""
    st.cache_data.clear()
    st.session_state.data_loaded = False
    st.rerun()


# ============================================================
# SIDEBAR
# ============================================================
def render_sidebar():
    """Render sidebar with portfolio selector, navigation and status"""
    
    # Sidebar: pure JS drag-to-resize. Streamlit 1.53 has no built-in handle.
    # Drag zone = rightmost 8px of sidebar. Max width = 1/3 of screen. No observers.
    sidebar_css = """
    <style>
        section[data-testid="stSidebar"] {
            min-width: 280px;
            width: 480px;
            flex-shrink: 0;
            position: relative;
        }
        section[data-testid="stSidebar"] > div:first-child {
            width: 100% !important;
        }
        /* Visual drag-handle strip on right edge */
        section[data-testid="stSidebar"]::after {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 6px; height: 100%;
            cursor: col-resize;
            background: rgba(120,120,120,0.15);
            z-index: 1000;
            transition: background 0.15s;
        }
        section[data-testid="stSidebar"]:hover::after {
            background: rgba(120,120,120,0.35);
        }
        .main .block-container {
            padding-left: 1.5rem !important;
            padding-right: 1.5rem !important;
            padding-top: 2rem !important;
            max-width: 100% !important;
        }
        .stChat { width: 100% !important; }
    </style>
    <script>
    (function() {
        var MIN_W = 280;
        function maxW() { return Math.max(600, window.innerWidth - 200); }  // Up to screen width minus 200px

        function applyWidth(w) {
            var sb = document.querySelector('section[data-testid="stSidebar"]');
            if (!sb) return;
            sb.style.setProperty('width', w + 'px', 'important');
            var main = document.querySelector('.main');
            if (main) { main.style.marginLeft = w + 'px'; }
        }

        function setup() {
            var sb = document.querySelector('section[data-testid="stSidebar"]');
            if (!sb) { setTimeout(setup, 200); return; }

            // Restore saved width from localStorage ‚Äî survives Streamlit rerenders
            var saved = localStorage.getItem('argus_sidebar_w');
            if (saved) {
                var w = Math.min(maxW(), Math.max(MIN_W, parseInt(saved, 10)));
                applyWidth(w);
            }

            // Avoid attaching multiple listeners on Streamlit rerenders
            if (sb._dragAttached) return;
            sb._dragAttached = true;

            sb.addEventListener('mousedown', function(e) {
                var rect = sb.getBoundingClientRect();
                // Only trigger drag if click is in the rightmost 8px
                if (e.clientX < rect.right - 8) return;
                e.preventDefault();
                var startX = e.clientX;
                var startW = rect.width;

                function onMove(ev) {
                    var newW = Math.min(maxW(), Math.max(MIN_W, startW + (ev.clientX - startX)));
                    applyWidth(newW);
                    // Persist immediately so rerenders pick it up
                    localStorage.setItem('argus_sidebar_w', newW);
                }
                function onUp() {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                }
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setup);
        } else {
            setup();
        }
        // Retry after Streamlit's initial render passes
        setTimeout(setup, 300);
        setTimeout(setup, 800);
        setTimeout(setup, 1500);
    })();
    </script>
    """

    st.markdown(sidebar_css, unsafe_allow_html=True)
    
    with st.sidebar:
        # Portfolio Selector (Collapsible)
        with st.expander("üìä Portfolio Selection", expanded=False):
            portfolio = st.radio(
                "Select Portfolio",
                ["üé° Income Wheel", "‚≠ê Active Core"],
                key="portfolio_selector",
                label_visibility="collapsed"
            )
            
            # Update session state
            if 'selected_portfolio' not in st.session_state:
                st.session_state.selected_portfolio = portfolio
            elif st.session_state.selected_portfolio != portfolio:
                st.session_state.selected_portfolio = portfolio
                # Clear cache when switching portfolios
                st.cache_data.clear()
                st.session_state.data_loaded = False
            
            # Portfolio-specific title
            if portfolio == "‚≠ê Active Core":
                st.caption("‚≠ê Active Core")
            else:
                st.caption("üé° Income Wheel")
        
        # Navigation (Collapsible)
        with st.expander("üß≠ Navigation", expanded=False):
            page = st.radio(
                "Navigate",
                ["üìä Dashboard", "üìã CIO Report", "üìÖ Daily Helper", "üìù Entry Forms",
                 "üìà Expiry Ladder", "üìä Performance", "üìã All Positions", "‚öôÔ∏è Margin Config", "üìö Strategy Instructions",
                 "üîç Income Scanner", "üì° Market Data"],
                key="navigation_radio",
                label_visibility="collapsed"
            )
            st.session_state.current_page = page
        
        st.divider()
        
        # AI Chat (persistent across all pages) - AFTER portfolio/page selection for proper context
        try:
            portfolio_name = portfolio.replace("üé° ", "").replace("‚≠ê ", "")
            portfolio_deposit = get_portfolio_deposit(portfolio_name)
            
            render_ai_chat(
                df_trades=st.session_state.df_trades,
                df_open=st.session_state.df_open,
                portfolio_deposit=portfolio_deposit,
                current_page=page,
                portfolio=portfolio_name
            )
        except Exception as e:
            st.error(f"AI Chat Error: {e}")
        
        # Strategy Selector (for Income Wheel portfolio) - Collapsible
        with st.expander("üéØ Strategy & Settings", expanded=False):
            if portfolio == "üé° Income Wheel":
                strategy_filter = st.radio(
                    "View Strategy",
                    ["All", "WHEEL", "PMCC"],
                    key="strategy_filter",
                    help="Filter views by strategy: WHEEL (CSP + CC) or PMCC (LEAP + CC)"
                )
                # Note: st.radio with key automatically manages st.session_state.strategy_filter
            else:
                # For other portfolios, set strategy filter to "All" if not already set
                if 'strategy_filter' not in st.session_state:
                    st.session_state.strategy_filter = "All"
            
            st.divider()
            
            # Price Feed Status
            st.caption("Live Prices")
            feed = PriceFeed()
            connected = feed.connect()  # Always True for Yahoo Finance
            st.session_state.ibkr_connected = connected  # Keep name for compatibility
            
            display_price_status(connected)
            if st.button("Refresh Prices"):
                st.cache_data.clear()
                st.rerun()
            
            st.divider()
            
            # Data status
            st.caption("Data Status")
            if st.button("üîÑ Refresh Data"):
                refresh_data()
            
            if st.session_state.df_trades is not None:
                df = st.session_state.df_trades
                st.caption(f"Total trades: {len(df)}")
                st.caption(f"Open: {len(df[df['Status'] == 'Open'])}")
        
        # Static reference: CSP pacing + shortcuts (minimizable at bottom of sidebar)
        with st.expander("üìã Strategy & shortcuts", expanded=False):
            st.markdown("**CSP deployment pacing**")
            st.markdown("- **Firepower:** Portfolio Deposit ‚àí Capital Locked in Stock")
            st.markdown("- **Weekly target:** Deploy ~25% of Firepower in new CSPs each week")
            st.markdown("- **Check:** Sum CSP reserved opened this week vs Weekly Target ‚Üí UNDER / ON TARGET / OVER")
            st.divider()
            st.markdown("**Shortcuts**")
            st.markdown("- **Dashboard:** Capital Cockpit, P/L, BP, Liquid cash")
            st.markdown("- **Daily Helper:** MARA CC 4-week coverage, live prices")
            st.markdown("- **Entry Forms:** New trade, Close, Split, BTC, Expire, Assignment, Exercise")
            st.markdown("- **Expiry Ladder:** Options by expiry")
            st.markdown("- **All Positions:** Filter by status, type, ticker")
            st.markdown("- **Margin Config:** Deposit, allocation")
        
        return page, portfolio


# ============================================================
# DASHBOARD PAGE
# ============================================================
def render_dashboard():
    """Render main dashboard"""
    st.title("üìä Dashboard")
    
    df_open = st.session_state.df_open
    df_trades = st.session_state.df_trades
    
    if df_open is None or df_open.empty:
        st.warning("No open positions found.")
        return
    
    # Always use current portfolio's persisted values (never stale from previous selection)
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    st.session_state.margin_percentages = get_margin_percentages(portfolio)
    st.session_state.portfolio_deposit = get_portfolio_deposit(portfolio)
    portfolio_deposit = st.session_state.portfolio_deposit
    
    # Get live prices for capital calculation (Yahoo Finance - always available)
    tickers = df_open['Ticker'].unique().tolist()
    live_prices = {}
    try:
        live_prices = get_cached_prices(tuple(tickers))
        st.session_state.live_prices = live_prices
        
        # Save current prices to persistent storage (for LLM reference and future API integration)
        from persistence import update_current_price
        for ticker, price in live_prices.items():
            if price is not None:
                update_current_price(ticker, price, source='yahoo', portfolio=portfolio)
        
        if live_prices:
            prices_count = sum(1 for p in live_prices.values() if p is not None)
            if prices_count > 0:
                st.info(f"üìä Prices loaded for {prices_count}/{len(tickers)} tickers (Yahoo Finance, 10-15 min delay)")
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Could not fetch live prices: {e}")
        live_prices = st.session_state.get('live_prices', {})
    
    # Get PMCC tickers for CSP Tank calculation
    pmcc_tickers = get_pmcc_tickers(portfolio)
    pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
    
    # Get stock average prices from Performance tab (from broker records)
    from persistence import get_stock_average_prices
    stock_avg_prices = get_stock_average_prices(portfolio)
    
    # Calculate capital usage using unified calculator
    from unified_calculations import UnifiedCapitalCalculator
    capital_data = UnifiedCapitalCalculator.calculate_capital_by_ticker(
        df_open, portfolio_deposit, stock_avg_prices, live_prices, pmcc_tickers_set
    )
    
    # Extract totals for backward compatibility with existing code
    total_stock_locked = capital_data['total']['stock_locked']
    total_csp_reserved = capital_data['total']['csp_reserved']
    total_leap_sunk = capital_data['total']['leap_sunk']
    total_committed = capital_data['total']['total_committed']
    
    # Keep old format for compatibility (if needed elsewhere)
    tank_data = {
        'locked': {
            'stock_locked': total_stock_locked,
            'true_csp_reserved': total_csp_reserved
        },
        'by_ticker': capital_data['by_ticker'],
        'health': {
            'starting_deposit': portfolio_deposit,
            'true_buying_power': capital_data['total']['remaining_bp'],
            'overleveraged': capital_data['total']['overleveraged'],
            'status': 'OVERLEVERAGED' if capital_data['total']['overleveraged'] else 'OK'
        }
    }
    pmcc_data = {
        'total': {
            'leap_sunk': total_leap_sunk,
            'remaining_buying_power': capital_data['total']['remaining_bp']
        }
    }
    
    # Show warning if capital seems too low (likely missing prices)
    total_used = tank_data['locked']['stock_locked'] + tank_data['locked']['true_csp_reserved']
    if total_used < 100000 and len(df_open[df_open['TradeType'].isin(['STOCK', 'LEAP'])]) > 10:
        missing_prices = df_open[
            (df_open['TradeType'].isin(['STOCK', 'LEAP'])) & 
            (pd.to_numeric(df_open['Price_of_current_underlying_(USD)'], errors='coerce').isna())
        ]
        if len(missing_prices) > 0:
            total_shares_missing = missing_prices.apply(
                lambda row: abs(pd.to_numeric(row.get('Open_lots', 0), errors='coerce') or 0) 
                if pd.notna(row.get('Open_lots')) 
                else abs(pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0) * 100, 
                axis=1
            ).sum()
            st.error(f"‚ö†Ô∏è **Warning:** {len(missing_prices)} positions with {total_shares_missing:,.0f} shares have missing prices. Prices will be fetched from Yahoo Finance, or update prices in Excel to see accurate capital deployment.")
    inventory = CapitalCalculator.calculate_inventory(df_open)
    
    # Save Open_lots to persistent storage (for LLM reference and future API integration)
    # CRITICAL: Only save actual STOCK shares, NOT LEAP shares equivalent
    # LEAP positions should NOT be saved to Open_lots as they are not actual stock holdings
    from persistence import save_open_lots
    open_lots_by_ticker = {}
    positions_by_ticker = inventory.get('positions_by_ticker', {})
    for ticker, ticker_data in positions_by_ticker.items():
        # Only save actual STOCK shares (not LEAP shares equivalent)
        stock_shares = ticker_data.get('stock', 0)  # Actual stock shares only
        if stock_shares > 0:
            open_lots_by_ticker[ticker] = float(stock_shares)
    if open_lots_by_ticker:
        save_open_lots(open_lots_by_ticker, portfolio=portfolio)
    
    # Live Prices Cards
    st.subheader("üìä Live Prices")
    if live_prices:
        price_cols = st.columns(min(len(tickers), 5))
        for idx, ticker in enumerate(tickers[:5]):  # Show first 5 tickers
            with price_cols[idx % len(price_cols)]:
                price = live_prices.get(ticker)
                if price is not None:
                    st_metric_with_negatives(ticker, price, decimals=2, is_currency=True)
                else:
                    st.metric(ticker, "N/A")
    
    # ----- Capital Cockpit: summary row + 3 sections (Stock, CSP, CCs) -----
    st.subheader("üí∞ Capital Cockpit")
    
    # Totals from unified capital (stock_locked = stock at current price)
    total_stock_locked = capital_data['total']['stock_locked']
    total_stock_at_buy = capital_data['total'].get('stock_at_buy_price', 0.0)
    total_stock_at_current = capital_data['total'].get('stock_at_current_price', total_stock_locked)
    total_stock_pl = capital_data['total'].get('stock_pl', 0.0)
    total_csp_reserved = capital_data['total']['csp_reserved']
    total_leap_sunk = capital_data['total']['leap_sunk']
    total_committed = capital_data['total']['total_committed']
    remaining_bp = capital_data['total']['remaining_bp']
    is_overleveraged = capital_data['total']['overleveraged']
    
    # Comprehensive P&L (same source as "Net P&L (Mark-to-Market)" section) so Total P/L matches
    from pnl_calculator import PnLCalculator
    from persistence import get_spy_leap_pl
    spy_leap_pl = get_spy_leap_pl(portfolio)
    comprehensive_pnl = PnLCalculator.calculate_comprehensive_pnl(
        df_trades=df_trades,
        df_open=df_open,
        stock_avg_prices=stock_avg_prices,
        live_prices=live_prices,
        spy_leap_pl=spy_leap_pl if spy_leap_pl != 0 else None
    )
    # Premium collected (same logic as Profit and Loss by Ticker: closed CC/CSP only)
    premium_collected_by_ticker = {}
    if df_trades is not None and not df_trades.empty:
        closed_opts = df_trades[(df_trades['Status'] == 'Closed') & (df_trades['TradeType'].isin(['CC', 'CSP']))].copy()
        if not closed_opts.empty:
            if 'Actual_Profit_(USD)' in closed_opts.columns:
                closed_opts['_prem'] = pd.to_numeric(closed_opts['Actual_Profit_(USD)'], errors='coerce').fillna(0)
            else:
                closed_opts['_prem'] = pd.to_numeric(closed_opts.get('OptPremium', 0), errors='coerce').fillna(0) * 100 * pd.to_numeric(closed_opts.get('Quantity', 0), errors='coerce').fillna(0)
            prem_agg = closed_opts.groupby('Ticker')['_prem'].sum()
            premium_collected_by_ticker = prem_agg.to_dict()
    total_premium_row = sum(premium_collected_by_ticker.values()) if premium_collected_by_ticker else 0.0
    total_stock_leap_pl = comprehensive_pnl['unrealized_stock_pnl']['total'] + comprehensive_pnl['unrealized_leap_pnl']['total']
    total_pl = total_premium_row + total_stock_leap_pl  # Total P/L = Total income + Total stock/LEAPs P/L
    
    # Keep tank_data / health for backward compatibility (used elsewhere)
    health = tank_data['health']
    locked = tank_data['locked']
    
    # ----- Summary row: read across explains Total P/L = Total income + Total stock/LEAPs P/L -----
    total_capital_used = total_stock_at_current + total_leap_sunk + total_csp_reserved  # same as total_committed
    capital_held = total_stock_at_current + total_leap_sunk  # capital held by stock (Stock + LEAP), excluding CSP
    # Liquid Cash = Starting Capital + Nett P/L - Capital Held by Stock (excluding CSP held)
    liquid_cash = (portfolio_deposit + total_pl) - capital_held
    # BP = Liquid Cash - CSP held
    bp = liquid_cash - total_csp_reserved
    st.write("**Summary**")
    col1, col2, col3, col4, col5, col6, col7 = st.columns(7)
    with col1:
        st.markdown("**Starting Deposit**<br>Initial Portfolio Deposit", unsafe_allow_html=True)
        st_metric_with_negatives("", portfolio_deposit, decimals=0, is_currency=True)
    with col2:
        st.markdown("**Capital Held**<br>Stock at current + LEAP Sunk", unsafe_allow_html=True)
        st_metric_with_negatives("", capital_held, decimals=0, is_currency=True)
    with col3:
        st.markdown("**Total Capital Used**<br>Capital Held + CSP reserved", unsafe_allow_html=True)
        st_metric_with_negatives("", total_capital_used, decimals=0, is_currency=True)
    with col4:
        st.markdown("**Total Premium Income**<br>Premium Collected (Closed CC/CSP)", unsafe_allow_html=True)
        st_metric_with_negatives("", total_premium_row, decimals=0, is_currency=True)
    with col5:
        st.markdown("**Nett P/L**<br>Total premium income + Total Stock/Leaps P/L", unsafe_allow_html=True)
        st_metric_with_negatives("", total_pl, decimals=0, is_currency=True)
    with col6:
        st.markdown("**Liquid Cash**<br>Starting Capital + Nett P/L ‚àí Capital Held by Stock", unsafe_allow_html=True)
        st_metric_with_negatives("", liquid_cash, decimals=0, is_currency=True)
    with col7:
        st.markdown("**BP**<br>Liquid Cash ‚àí CSP held", unsafe_allow_html=True)
        st_metric_with_negatives("", bp, decimals=0, is_currency=True)
    st.divider()
    
    # ----- Section 1: Total Stock, CSP reserved, Total capital used in one row -----
    st.write("**Stock capital & LEAP/PMCC capital**")
    
    stock_and_leap_total = total_stock_at_current + total_leap_sunk  # Total Stock = Stock at current + LEAP sunk (PMCC/LEAP e.g. SPY = one ticker)
    
    cap_col1, cap_col2, cap_col3 = st.columns(3)
    with cap_col1:
        st.markdown("**Total Stock**<br>Total Stock", unsafe_allow_html=True)
        st_metric_with_negatives("", stock_and_leap_total, decimals=0, is_currency=True)
    with cap_col2:
        st.markdown("**CSP reserved**<br>CSP reserved", unsafe_allow_html=True)
        st_metric_with_negatives("", total_csp_reserved, decimals=0, is_currency=True)
    with cap_col3:
        st.markdown("**Total Capital Used**<br>Total Capital Used/Held", unsafe_allow_html=True)
        st_metric_with_negatives("", total_capital_used, decimals=0, is_currency=True)
    
    # ----- CSP Reserved expandable: Open CSPs, Counters, Expiry, Income ladder (YTD, MTD, Next 4 weeks) -----
    with st.expander("CSP Reserved ‚Äì Open CSPs, counters, expiry & income ladder (pace and deploy BP)", expanded=False):
        df_csp_open = df_open[(df_open['TradeType'] == 'CSP')].copy() if df_open is not None and not df_open.empty and 'TradeType' in df_open.columns else pd.DataFrame()
        if not df_csp_open.empty:
            df_csp_open = df_csp_open.copy()
            df_csp_open['Expiry_Date'] = pd.to_datetime(df_csp_open['Expiry_Date'], errors='coerce')
            strike_col = 'Option_Strike_Price_(USD)' if 'Option_Strike_Price_(USD)' in df_csp_open.columns else 'Strike'
            qty_col = 'Quantity'
            prem_col = 'OptPremium'
            df_csp_open['Reserved'] = pd.to_numeric(df_csp_open.get(strike_col, 0), errors='coerce').fillna(0) * 100 * pd.to_numeric(df_csp_open[qty_col], errors='coerce').fillna(0)
            df_csp_open['Premium_at_expiry'] = pd.to_numeric(df_csp_open.get(prem_col, 0), errors='coerce').fillna(0) * 100 * pd.to_numeric(df_csp_open[qty_col], errors='coerce').fillna(0)
            cols_show = [c for c in ['Ticker', 'TradeID', strike_col, qty_col, 'Expiry_Date', 'Reserved', 'Premium_at_expiry'] if c in df_csp_open.columns]
            st.write("**Open CSPs**")
            exp_display = df_csp_open['Expiry_Date'].dt.strftime('%Y-%m-%d') if df_csp_open['Expiry_Date'].notna().any() else df_csp_open['Expiry_Date'].astype(str)
            st.dataframe(df_csp_open[cols_show].assign(Expiry_Date=exp_display), use_container_width=True, hide_index=True)
            counters = sorted(df_csp_open['Ticker'].dropna().unique().tolist())
            st.write("**Counters:** " + ", ".join(counters) if counters else "‚Äî")
        else:
            st.write("**Open CSPs:** None.")
            counters = []
        st.write("**Income ladder (CSP only)**")
        df_trades_csp = df_trades[(df_trades['TradeType'] == 'CSP')].copy() if df_trades is not None and not df_trades.empty and 'TradeType' in df_trades.columns else pd.DataFrame()
        df_open_csp = df_csp_open.copy() if not df_csp_open.empty else pd.DataFrame()
        ytd_csp = month_csp = 0.0
        if not df_trades_csp.empty:
            df_trades_csp['Expiry_Date'] = pd.to_datetime(df_trades_csp['Expiry_Date'], errors='coerce')
            closed_csp = df_trades_csp[df_trades_csp['Status'].str.upper() == 'CLOSED']
            if not closed_csp.empty and 'Actual_Profit_(USD)' in closed_csp.columns:
                closed_csp = closed_csp.copy()
                closed_csp['_profit'] = pd.to_numeric(closed_csp['Actual_Profit_(USD)'], errors='coerce').fillna(0)
                closed_csp['_expiry_d'] = closed_csp['Expiry_Date'].dt.date
                today_d = date.today()
                ytd_csp = closed_csp[closed_csp['_expiry_d'].apply(lambda x: x.year == today_d.year if hasattr(x, 'year') else False)]['_profit'].sum()
                start_m = date(today_d.year, today_d.month, 1)
                end_m = date(today_d.year, today_d.month + 1, 1) - timedelta(days=1) if today_d.month < 12 else date(today_d.year + 1, 1, 1) - timedelta(days=1)
                month_csp = closed_csp[(closed_csp['_expiry_d'] >= start_m) & (closed_csp['_expiry_d'] <= end_m)]['_profit'].sum()
        lc1, lc2, lc3 = st.columns(3)
        with lc1:
            st.metric("CSP income YTD", f"${float(ytd_csp):,.0f}")
        with lc2:
            st.metric("CSP income MTD", f"${float(month_csp):,.0f}")
        next4_rows = []
        if not df_open_csp.empty and 'Expiry_Date' in df_open_csp.columns and 'Premium_at_expiry' in df_open_csp.columns:
            today_d = date.today()
            days_until_fri = (4 - today_d.weekday()) % 7
            next_fri = today_d + timedelta(days=days_until_fri)
            for i in range(4):
                week_end = next_fri + timedelta(days=7 * i)
                week_start = week_end - timedelta(days=6)
                mask = (df_open_csp['Expiry_Date'].dt.date >= week_start) & (df_open_csp['Expiry_Date'].dt.date <= week_end)
                exp_week = df_open_csp.loc[mask]
                prem_week = exp_week['Premium_at_expiry'].sum()
                next4_rows.append({"Week ending": week_end.strftime("%Y-%m-%d"), "CSP premium (expiring)": prem_week})
        with lc3:
            if next4_rows:
                st.write("**Next 4 weeks (expiring)**")
                st.dataframe(pd.DataFrame(next4_rows), use_container_width=True, hide_index=True)
            else:
                st.write("**Next 4 weeks:** No open CSPs expiring.")
        st.caption("Use this to pace and deploy available BP.")
    
    st.divider()
    
    # ----- Profit and Loss (by Ticker) - one line + dropdown for details -----
    # comprehensive_pnl already computed above for Total P/L in summary
    st.write("**Profit and Loss (by Ticker)**")
    
    # Summary card: Nett = Total Premium + Total P/L
    nett_pl = total_pl  # Total premium income + Total Stock/Leaps P/L (from summary)
    nett_str = f"${nett_pl:,.0f}" if nett_pl >= 0 else f"(${abs(nett_pl):,.0f})"
    nett_color = "#0f172a" if nett_pl >= 0 else "#ff4444"
    st.markdown(
        f'''
        <div style="background: #f8fafc; border-radius: 12px; padding: 1rem 1.25rem; margin: 0.75rem 0; border: 1px solid #e2e8f0;">
            <p style="color: #1e3a5f; font-size: 0.85rem; font-weight: 600; margin: 0 0 0.25rem 0;">Nett P/L</p>
            <p style="color: {nett_color}; font-size: 1.5rem; font-weight: 700; margin: 0;">{nett_str}</p>
            <p style="color: #64748b; font-size: 0.75rem; margin: 0.35rem 0 0 0;">Total Premium Income + Total P/L (Stock + LEAP)</p>
        </div>
        ''',
        unsafe_allow_html=True
    )
    
    # Premium collected by ticker (from closed CC/CSP trades)
    premium_collected_by_ticker = {}
    if df_trades is not None and not df_trades.empty:
        closed_opts = df_trades[(df_trades['Status'] == 'Closed') & (df_trades['TradeType'].isin(['CC', 'CSP']))].copy()
        if not closed_opts.empty:
            if 'Actual_Profit_(USD)' in closed_opts.columns:
                closed_opts['_prem'] = pd.to_numeric(closed_opts['Actual_Profit_(USD)'], errors='coerce').fillna(0)
            else:
                closed_opts['_prem'] = pd.to_numeric(closed_opts.get('OptPremium', 0), errors='coerce').fillna(0) * 100 * pd.to_numeric(closed_opts.get('Quantity', 0), errors='coerce').fillna(0)
            prem_agg = closed_opts.groupby('Ticker')['_prem'].sum()
            premium_collected_by_ticker = prem_agg.to_dict()
    
    stock_pl_by_ticker = comprehensive_pnl.get('unrealized_stock_pnl', {}).get('by_ticker', {})
    leap_pl_by_ticker = comprehensive_pnl.get('unrealized_leap_pnl', {}).get('by_ticker', {})
    all_pl_tickers = sorted(set(stock_pl_by_ticker.keys()) | set(leap_pl_by_ticker.keys()) | set(premium_collected_by_ticker.keys()))
    
    if all_pl_tickers:
        # Row total: premium collected
        total_premium_row = sum(premium_collected_by_ticker.get(t, 0.0) for t in all_pl_tickers)
        total_stock_pl_row = sum(stock_pl_by_ticker.get(t, 0.0) for t in all_pl_tickers)
        total_leap_pl_row = sum(leap_pl_by_ticker.get(t, 0.0) for t in all_pl_tickers)
        total_pl_row = total_stock_pl_row + total_leap_pl_row
        
        # One line: Premium collected by ticker + Total (before P/L)
        st.caption("Premium collected (closed CC/CSP)")
        n_cols = min(len(all_pl_tickers), 8)
        prem_cols = st.columns(n_cols + 1)
        for i, ticker in enumerate(all_pl_tickers[:n_cols]):
            prem = premium_collected_by_ticker.get(ticker, 0.0)
            with prem_cols[i]:
                st_metric_with_negatives(ticker, prem, decimals=0, is_currency=True,
                                         help_text="Premium collected from closed CC/CSP")
        with prem_cols[n_cols]:
            st_metric_with_negatives("Total", total_premium_row, decimals=0, is_currency=True,
                                     help_text="Total premium collected (all tickers)")
        if len(all_pl_tickers) > 8:
            st.caption(f"Showing first 8 of {len(all_pl_tickers)} tickers. See dropdown for full list.")
        
        # One line: P/L per ticker + Total P/L
        st.caption("Unrealized P/L (Stock + LEAP)")
        n_pl = min(len(all_pl_tickers), 8)
        pl_cols = st.columns(n_pl + 1)
        for i, ticker in enumerate(all_pl_tickers[:n_pl]):
            stock_pl = stock_pl_by_ticker.get(ticker, 0.0)
            leap_pl = leap_pl_by_ticker.get(ticker, 0.0)
            total_pl = stock_pl + leap_pl
            with pl_cols[i]:
                st_metric_with_negatives(ticker, total_pl, decimals=0, is_currency=True,
                                         help_text=f"Stock P/L: ${stock_pl:,.0f} | LEAP P/L: ${leap_pl:,.0f}")
        with pl_cols[n_pl]:
            st_metric_with_negatives("Total P/L", total_pl_row, decimals=0, is_currency=True,
                                     help_text="Sum of all tickers (Stock + LEAP unrealized P/L)")
    else:
        st.caption("No premium or unrealized P/L data by ticker.")
    
    st.divider()
    
    # ----- Minimizable breakdowns at bottom (Stock Capital, CSP reserved) -----
    st.subheader("üìã Detail breakdowns")
    stock_and_leap_tickers = [t for t, d in capital_data['by_ticker'].items() if d.get('stock_at_current_price', 0) != 0 or d.get('stock_at_buy_price', 0) != 0 or d.get('leap_sunk', 0) != 0]
    if stock_and_leap_tickers and stock_and_leap_total > 0:
        with st.expander("Total Stock by ticker (Stock + LEAP) with % used", expanded=False):
            from data_access import DataAccess
            rows = []
            for ticker in sorted(stock_and_leap_tickers):
                d = capital_data['by_ticker'][ticker]
                at_cur = d.get('stock_at_current_price', 0)
                leap_sunk = d.get('leap_sunk', 0)
                ticker_total_stock = at_cur + leap_sunk
                pct_used = (ticker_total_stock / stock_and_leap_total * 100) if stock_and_leap_total else 0.0
                shares = int(DataAccess.get_stock_shares(ticker, DataAccess.filter_open_positions(df_open)))
                rows.append({
                    'Ticker': ticker,
                    'Shares': shares,
                    'Stock at current': at_cur,
                    'LEAP sunk': leap_sunk,
                    'Total Stock': ticker_total_stock,
                    '% used': f"{pct_used:.1f}%"
                })
            if rows:
                df_stock = pd.DataFrame(rows)
                st.dataframe(
                    style_dataframe_negatives(df_stock, currency_columns=['Stock at current', 'LEAP sunk', 'Total Stock']),
                    use_container_width=True, hide_index=True
                )
    csp_tickers = [t for t, d in capital_data['by_ticker'].items() if d.get('csp_reserved', 0) > 0]
    if csp_tickers:
        with st.expander("CSP by ticker (Ticker | Contracts | Reserved)", expanded=False):
            rows = []
            for ticker in sorted(csp_tickers):
                d = capital_data['by_ticker'][ticker]
                reserved = d.get('csp_reserved', 0)
                csp_pos = df_open[(df_open['Ticker'] == ticker) & (df_open['TradeType'] == 'CSP')] if 'Ticker' in df_open.columns and 'TradeType' in df_open.columns else pd.DataFrame()
                contracts = int(csp_pos['Quantity'].abs().sum()) if not csp_pos.empty and 'Quantity' in csp_pos.columns else 0
                rows.append({'Ticker': ticker, 'Contracts': contracts, 'Reserved': reserved})
            if rows:
                st.dataframe(
                    style_dataframe_negatives(pd.DataFrame(rows), currency_columns=['Reserved']),
                    use_container_width=True, hide_index=True
                )
    st.divider()
    
    # Premium Stats (based on expiry dates)
    
    st.subheader("üíµ Premium Collected (Options Only)")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        week_stats = PremiumCalculator.calculate_premium_stats(df_trades, df_open, 'week')
        st_metric_with_negatives("To Collect This Week", week_stats.get('premium_to_collect', 0), 
                                 delta="Expiring + Open", decimals=0, is_currency=True)
        collected_text = format_currency_for_display(week_stats.get('premium_collected', 0), decimals=0, show_cents=False)
        st.markdown(f"Collected: {collected_text}", unsafe_allow_html=True)
    
    with col2:
        week_stats = PremiumCalculator.calculate_premium_stats(df_trades, df_open, 'week')
        st_metric_with_negatives("Collected This Week", week_stats.get('premium_collected', 0),
                                 delta="Expired + Closed", decimals=0, is_currency=True)
    
    with col3:
        month_stats = PremiumCalculator.calculate_premium_stats(df_trades, df_open, 'month')
        st_metric_with_negatives("Month to Date", month_stats['total_premium'],
                                 delta="Expiry this month", decimals=0, is_currency=True)
    
    with col4:
        ytd_stats = PremiumCalculator.calculate_premium_stats(df_trades, df_open, 'ytd')
        st_metric_with_negatives("Year to Date", ytd_stats['total_premium'],
                                 delta="Expiry this year", decimals=0, is_currency=True)
    
    # Premium breakdown by ticker
    st.write("**Premium Breakdown by Ticker:**")
    
    # Calculate premium by ticker for each period
    ticker_premium_data = []
    all_tickers = df_trades['Ticker'].unique().tolist()
    
    for ticker in all_tickers:
        ticker_trades = df_trades[df_trades['Ticker'] == ticker].copy()
        if not df_open.empty:
            ticker_open = df_open[df_open['Ticker'] == ticker].copy()
        else:
            ticker_open = pd.DataFrame()
        
        # Week stats
        week_stats = PremiumCalculator.calculate_premium_stats(ticker_trades, ticker_open if not ticker_open.empty else None, 'week')
        # Month stats
        month_stats = PremiumCalculator.calculate_premium_stats(ticker_trades, ticker_open if not ticker_open.empty else None, 'month')
        # YTD stats
        ytd_stats = PremiumCalculator.calculate_premium_stats(ticker_trades, ticker_open if not ticker_open.empty else None, 'ytd')
        
        ticker_premium_data.append({
            'Ticker': ticker,
            'To Collect This Week': week_stats.get('premium_to_collect', 0),
            'Collected This Week': week_stats.get('premium_collected', 0),
            'Month to Date': month_stats.get('total_premium', 0),
            'Year to Date': ytd_stats.get('total_premium', 0)
        })
    
    if ticker_premium_data:
        df_premium_by_ticker = pd.DataFrame(ticker_premium_data)
        df_premium_by_ticker = df_premium_by_ticker.sort_values('Year to Date', ascending=False)
        
        # Format for display with negative value handling
        df_premium_display = df_premium_by_ticker.copy()
        # Apply styling for negative values (red color) - this will format the currency columns
        styled_df = style_dataframe_negatives(df_premium_display, 
                                               currency_columns=['To Collect This Week', 'Collected This Week', 'Month to Date', 'Year to Date'])
        
        st.dataframe(
            styled_df,
            use_container_width=True,
            hide_index=True,
            column_config={
                "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                "To Collect This Week": st.column_config.TextColumn("To Collect This Week", width="medium"),
                "Collected This Week": st.column_config.TextColumn("Collected This Week", width="medium"),
                "Month to Date": st.column_config.TextColumn("Month to Date", width="medium"),
                "Year to Date": st.column_config.TextColumn("Year to Date", width="medium")
            }
        )
    else:
        st.info("No premium data available by ticker.")
    
    st.divider()
    
    # Position Inventory - By Ticker breakdown with CC coverage ratio
    st.subheader("üì¶ Position Inventory by Ticker")
    if inventory['positions_by_ticker']:
        st.write("**By Ticker:**")
        ticker_data = []
        for ticker, counts in inventory['positions_by_ticker'].items():
            # Format CC coverage ratio
            # If ratio > 0 and <= 1.0: Stock coverage % (stock shares / CC shares needed)
            # If ratio > 1.0: CC/LEAP ratio (CC contracts / LEAPs, multiply by 100 for %)
            # If ratio < 0: Uncovered (flag value -1.0)
            if counts.get('cc_coverage_ratio') is not None:
                coverage_ratio = counts['cc_coverage_ratio']
                if coverage_ratio < 0:
                    # Uncovered CCs (no stock/LEAPs)
                    coverage_display = "Uncovered ‚ö†Ô∏è"
                elif coverage_ratio <= 1.0:
                    # Stock coverage % (CC shares needed / stock shares)
                    # Shows what % of shares are committed to covering calls
                    coverage_pct = coverage_ratio * 100
                    if coverage_pct >= 100:
                        coverage_display = f"{coverage_pct:.0f}% ‚úÖ"
                    elif coverage_pct >= 80:
                        coverage_display = f"{coverage_pct:.0f}% ‚ö†Ô∏è"
                    else:
                        # Under 80% means well covered with excess capacity
                        coverage_display = f"{coverage_pct:.0f}% ‚úÖ"
                else:
                    # Over 100% means uncovered (more calls than shares can cover)
                    coverage_pct = coverage_ratio * 100
                    coverage_display = f"{coverage_pct:.0f}% ‚ùå"
            else:
                coverage_display = "N/A"
            
            ticker_data.append({
                'Ticker': ticker,
                'CC': counts['cc'],
                'CSP': counts['csp'],
                'Stock (shares)': counts.get('stock', 0),
                'LEAPs (shares)': counts.get('leaps', 0),
                'Total Stock (shares)': counts.get('total_stock', counts.get('stock', 0)),
                'CC Coverage': coverage_display
            })
        df_ticker = pd.DataFrame(ticker_data)
        
        # Format numbers for alignment
        df_ticker_display = df_ticker.copy()
        df_ticker_display['CC'] = df_ticker_display['CC'].apply(lambda x: f"{int(x):,}" if pd.notna(x) else "0")
        df_ticker_display['CSP'] = df_ticker_display['CSP'].apply(lambda x: f"{int(x):,}" if pd.notna(x) else "0")
        df_ticker_display['Stock (shares)'] = df_ticker_display['Stock (shares)'].apply(lambda x: f"{int(x):,}" if pd.notna(x) else "0")
        df_ticker_display['LEAPs (shares)'] = df_ticker_display['LEAPs (shares)'].apply(lambda x: f"{int(x):,}" if pd.notna(x) else "0")
        df_ticker_display['Total Stock (shares)'] = df_ticker_display['Total Stock (shares)'].apply(lambda x: f"{int(x):,}" if pd.notna(x) else "0")
        
        # Improved visual table with styling and alignment
        st.dataframe(
            df_ticker_display,
            use_container_width=True,
            hide_index=True,
            column_config={
                "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                "CC": st.column_config.TextColumn("CC", width="small"),
                "CSP": st.column_config.TextColumn("CSP", width="small"),
                "Stock (shares)": st.column_config.TextColumn("Stock (shares)", width="medium"),
                "LEAPs (shares)": st.column_config.TextColumn("LEAPs (shares)", width="medium"),
                "Total Stock (shares)": st.column_config.TextColumn("Total Stock (shares)", width="medium"),
                "CC Coverage": st.column_config.TextColumn("CC Coverage", width="medium")
            }
        )
        st.caption("CC Coverage: If LEAPs exist, shows CC/LEAP ratio. Otherwise shows stock coverage % (CC shares needed / stock shares). Under 100% = fully covered ‚úÖ, Over 100% = uncovered ‚ùå")
    
    st.divider()
    
    
# ============================================================
# DAILY HELPER PAGE
# ============================================================
def render_daily_helper():
    """Render daily helper page"""
    st.title("üìÖ Daily Helper")
    
    df_open = st.session_state.df_open
    live_prices = st.session_state.live_prices
    
    if df_open is None or df_open.empty:
        st.warning("No open positions found.")
        return
    
    # Filter by strategy if selected
    strategy_filter = st.session_state.get('strategy_filter', 'All')
    if strategy_filter != 'All':
        portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
        pmcc_tickers = get_pmcc_tickers(portfolio)
        pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
        
        if strategy_filter == 'PMCC':
            pmcc_mask = (
                df_open['Ticker'].isin(pmcc_tickers_set) |
                (df_open.get('StrategyType', '') == 'PMCC') |
                (df_open['TradeType'] == 'LEAP')
            )
            df_open = df_open[pmcc_mask].copy()
        elif strategy_filter == 'WHEEL':
            wheel_mask = (
                ~df_open['Ticker'].isin(pmcc_tickers_set) &
                (
                    (df_open.get('StrategyType', '') == 'Wheel') |
                    (df_open.get('StrategyType', '').isna()) |
                    (df_open.get('StrategyType', '') == '')
                ) &
                (df_open['TradeType'] != 'LEAP')
            )
            df_open = df_open[wheel_mask].copy()
        
        if df_open.empty:
            st.info(f"‚ÑπÔ∏è No open positions found for {strategy_filter} strategy.")
            return
    
    # Get live prices (Yahoo Finance - always available)
    tickers = df_open['Ticker'].unique().tolist()
    
    try:
        live_prices = get_cached_prices(tuple(tickers))
        st.session_state.live_prices = live_prices
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Could not fetch prices: {e}")
        live_prices = st.session_state.get('live_prices', {})

    # Fetch options data + Greeks for open positions (Mode 1 ‚Äî auto-feed)
    try:
        df_options_open = df_open[df_open['TradeType'].isin(['CC', 'CSP'])].copy()
        if not df_options_open.empty:
            open_positions_data = _market_data.get_open_positions_data(df_options_open)
            st.session_state.open_positions_data = open_positions_data
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Could not fetch options data: {e}")

    # Display connection status
    display_price_status(True)
    
    st.divider()
    
    # Live prices display
    st.subheader("üìà Live Prices")
    price_cols = st.columns(len(tickers))
    for i, ticker in enumerate(tickers):
        with price_cols[i]:
            price = live_prices.get(ticker)
            if price:
                st.metric(ticker, f"${price:.2f}")
            else:
                # Fallback to last known price from Excel
                last_price = df_open[df_open['Ticker'] == ticker]['Price_of_current_underlying_(USD)'].iloc[0]
                st.metric(ticker, f"${last_price:.2f}", "Last known")
    
    st.divider()

    # ============================================================
    # MARA CC 5-Week Coverage Planner (next five weekly expiries)
    # ============================================================
    st.subheader("üß≠ MARA CC Coverage Planner (Next 5 Weekly Expiries)")
    st.caption("Logic: for each of the next 5 Fridays, To Sell = Weekly Target (38) - Existing MARA CC contracts expiring that Friday.")

    try:
        from datetime import date as _date, timedelta as _timedelta

        WEEKLY_TARGET = 38
        today_d = _date.today()
        # Upcoming Friday (include today if it's Friday)
        days_until_fri = (4 - today_d.weekday()) % 7
        upcoming_fri = today_d + _timedelta(days=days_until_fri)
        expiry_targets = [upcoming_fri + _timedelta(days=7 * i) for i in range(5)]

        mara_cc = df_open[(df_open["Ticker"] == "MARA") & (df_open["TradeType"] == "CC")].copy()
        mara_cc["Expiry_Date"] = pd.to_datetime(mara_cc["Expiry_Date"], errors="coerce").dt.date
        mara_cc["Quantity_num"] = pd.to_numeric(mara_cc["Quantity"], errors="coerce").fillna(0).abs()

        planner_rows = []
        for exp in expiry_targets:
            week_rows = mara_cc[mara_cc["Expiry_Date"] == exp]
            existing_contracts = int(week_rows["Quantity_num"].sum()) if not week_rows.empty else 0
            trade_ids = ", ".join(week_rows["TradeID"].astype(str).tolist()) if not week_rows.empty else ""
            to_sell = max(0, WEEKLY_TARGET - existing_contracts)
            planner_rows.append(
                {
                    "Expiry (Fri)": exp.strftime("%Y-%m-%d"),
                    "Existing Contracts": existing_contracts,
                    "Weekly Target": WEEKLY_TARGET,
                    "To Sell": to_sell,
                    "TradeIDs (matched)": trade_ids,
                }
            )

        df_planner = pd.DataFrame(planner_rows)
        st.dataframe(
            df_planner,
            use_container_width=True,
            hide_index=True,
            column_config={
                "Expiry (Fri)": st.column_config.TextColumn("Expiry (Fri)", width="small"),
                "Existing Contracts": st.column_config.NumberColumn("Existing", width="small", format="%d"),
                "Weekly Target": st.column_config.NumberColumn("Target", width="small", format="%d"),
                "To Sell": st.column_config.NumberColumn("To Sell", width="small", format="%d"),
                "TradeIDs (matched)": st.column_config.TextColumn("TradeIDs (matched)", width="large"),
            },
        )
        st.info(
            "Strategic options: fill near-term gaps with short-DTE sales, or build future coverage by selling longer-DTE to cover larger shortfalls further out."
        )
    except Exception as e:
        st.warning(f"Could not build MARA CC coverage planner: {e}")
    
    # Expiring Soon
    st.subheader(f"‚è∞ Expiring Within {EXPIRING_SOON_DTE} Days")
    
    # Calculate DTE for all positions - ONLY include options (CC, CSP), exclude STOCK and LEAP
    # STOCK has no expiry date, LEAPs are long-term (shouldn't be in "expiring soon")
    df_expiring = df_open[df_open['TradeType'].isin(['CC', 'CSP'])].copy()
    df_expiring['Expiry_Date'] = pd.to_datetime(df_expiring['Expiry_Date'], errors='coerce')
    # Filter out positions with invalid expiry dates
    df_expiring = df_expiring[df_expiring['Expiry_Date'].notna()]
    # DTE inclusive: today + expiry day both count (e.g. 19 Feb ‚Üí 20 Feb = 2 DTE)
    df_expiring['DTE_Calc'] = (df_expiring['Expiry_Date'] - pd.Timestamp.now()).dt.days + 1
    df_expiring = df_expiring[df_expiring['DTE_Calc'] <= EXPIRING_SOON_DTE]
    
    if df_expiring.empty:
        st.success("‚úÖ No positions expiring within 10 days")
    else:
        # Add call risk
        df_expiring = RiskCalculator.calculate_call_risk(df_expiring, live_prices)
        
        # Calculate distance to spot
        df_expiring = df_expiring.copy()
        df_expiring['Current_Price'] = df_expiring['Ticker'].map(lambda t: live_prices.get(t, 0))
        df_expiring['Strike'] = pd.to_numeric(df_expiring['Option_Strike_Price_(USD)'], errors='coerce')
        
        # Distance to spot: For CC, it's (current - strike), for CSP it's (strike - current)
        # Positive = ITM, Negative = OTM
        df_expiring['Distance_to_Spot'] = df_expiring.apply(
            lambda row: (row['Current_Price'] - row['Strike']) if row['TradeType'] == 'CC' 
                       else (row['Strike'] - row['Current_Price']), 
            axis=1
        )
        
        # Group by ticker and sort (MARA, CRCL, SPY first, then others)
        tickers_expiring = df_expiring['Ticker'].unique().tolist()
        priority_tickers = ['MARA', 'CRCL', 'SPY']
        sorted_tickers = sorted([t for t in tickers_expiring if t in priority_tickers], 
                               key=lambda x: priority_tickers.index(x)) + \
                        sorted([t for t in tickers_expiring if t not in priority_tickers])
        
        # Calculate this week's date range (Monday to Sunday) for highlighting
        today = date.today()
        start_of_week_highlight = today - timedelta(days=today.weekday())  # Monday
        end_of_week_highlight = start_of_week_highlight + timedelta(days=6)  # Sunday
        
        for ticker in sorted_tickers:
            ticker_positions = df_expiring[df_expiring['Ticker'] == ticker].copy()
            
            # Sort by DTE (ascending - closest expiry first), then by Distance to Spot (descending - most ITM/risky first)
            ticker_positions = ticker_positions.sort_values(['DTE_Calc', 'Distance_to_Spot'], ascending=[True, False])
            
            # Calculate total quantity for this ticker
            total_qty = pd.to_numeric(ticker_positions['Quantity'], errors='coerce').fillna(0).abs().sum()
            
            # Show ticker header and quantity card (no duplication)
            col1, col2 = st.columns([3, 1])
            with col1:
                st.write(f"### üìä {ticker}")
            with col2:
                st.metric("Total Quantity", f"{int(total_qty):,}")
            
            # Create a table for this ticker
            display_data = []
            expiry_dates_list = []  # Store expiry dates for styling
            for _, row in ticker_positions.iterrows():
                risk = row.get('CallRisk', 'NONE')
                risk_emoji = {
                    'HIGH': 'üî¥',
                    'MEDIUM': 'üü°',
                    'LOW': 'üü†',
                    'NONE': 'üü¢'
                }.get(risk, '‚ö™')
                
                distance_pct = (row['Distance_to_Spot'] / row['Strike'] * 100) if row['Strike'] > 0 else 0
                distance_str = f"{row['Distance_to_Spot']:.2f} ({distance_pct:+.1f}%)"
                
                qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
                expiry_date = pd.to_datetime(row['Expiry_Date']).strftime('%Y-%m-%d') if pd.notna(row['Expiry_Date']) else 'N/A'
                expiry_date_obj = pd.to_datetime(row['Expiry_Date']).date() if pd.notna(row['Expiry_Date']) else None
                
                # Calculate premium expected
                premium = pd.to_numeric(row.get('OptPremium', 0), errors='coerce') or 0.0
                premium_expected = premium * qty * 100
                
                # Check if expires this week
                expires_this_week = False
                if expiry_date_obj:
                    expires_this_week = start_of_week_highlight <= expiry_date_obj <= end_of_week_highlight
                
                expiry_dates_list.append(expires_this_week)
                
                display_data.append({
                    'TradeID': row['TradeID'],
                    'Type': row['TradeType'],
                    'Quantity': int(qty),
                    'Expiry Date': expiry_date,
                    'Strike': f"${row['Strike']:.2f}",
                    'Current': f"${row['Current_Price']:.2f}",
                    'DTE': f"{int(row['DTE_Calc'])} days",
                    'Distance to Spot': distance_str,
                    'Premium Expected': f"${premium_expected:,.2f}",
                    'Risk': f"{risk_emoji} {risk}" if risk != 'NONE' else f"{risk_emoji} Safe"
                })
            
            df_display = pd.DataFrame(display_data)
            
            # Apply styling: light blue background for rows expiring this week
            def highlight_this_week(row):
                # Check if this row expires this week (using the row index)
                row_idx = row.name
                if row_idx < len(expiry_dates_list) and expiry_dates_list[row_idx]:
                    return ['background-color: #E3F2FD'] * len(row)
                return [''] * len(row)
            
            styled_df = df_display.style.apply(highlight_this_week, axis=1)
            
            st.dataframe(
                styled_df,
                use_container_width=True,
                hide_index=True,
                column_config={
                    "TradeID": st.column_config.TextColumn("TradeID", width="small"),
                    "Type": st.column_config.TextColumn("Type", width="small"),
                    "Quantity": st.column_config.NumberColumn("Quantity", width="small", format="%d"),
                    "Expiry Date": st.column_config.TextColumn("Expiry Date", width="small"),
                    "Strike": st.column_config.TextColumn("Strike", width="small"),
                    "Current": st.column_config.TextColumn("Current", width="small"),
                    "DTE": st.column_config.TextColumn("DTE", width="small"),
                    "Distance to Spot": st.column_config.TextColumn("Distance to Spot", width="medium"),
                    "Premium Expected": st.column_config.TextColumn("Premium Expected", width="medium"),
                    "Risk": st.column_config.TextColumn("Risk", width="medium")
                }
            )
            st.divider()
    
    st.divider()
    
    # Today's Selling Targets - Split into CSP (left) and CC (right)
    st.subheader("üéØ Today's Selling Target (By Ticker)")
    
    # Get inventory
    inventory = CapitalCalculator.calculate_inventory(df_open)
    # Note: Margin % calculations temporarily disabled - keeping config table only
    
    # Get capital allocation from persistence
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    capital_allocation = get_capital_allocation(portfolio)
    
    # Get contracts sold this week by ticker and type
    now = datetime.now()
    start_of_week = now - timedelta(days=now.weekday())
    df_trades = st.session_state.df_trades.copy()
    df_trades['Date_open'] = pd.to_datetime(df_trades['Date_open'], errors='coerce')
    
    this_week_trades = df_trades[
        (df_trades['Date_open'] >= start_of_week) &
        (df_trades['TradeType'].isin(['CC', 'CSP']))
    ].copy()
    
    all_tickers = sorted(df_open['Ticker'].unique().tolist())
    
    # Create two columns: CSP (left) and CC (right)
    col_left, col_right = st.columns(2)
    
    with col_left:
        st.markdown("#### üìâ CSP Selling Target")
        st.caption("Based on remaining capital allocation")
        
        # Prepare CSP data for all tickers
        csp_data = []
        for ticker in all_tickers:
            # Get capital allocated for this ticker
            capital_allocated = capital_allocation.get(ticker, 0.0)
            
            # Calculate capital used for this ticker
            capital_used = 0.0
            ticker_positions = df_open[df_open['Ticker'] == ticker]
            for _, pos in ticker_positions.iterrows():
                trade_id = pos['TradeID']
                # Margin % calculations temporarily disabled
                # Capital used calculation removed for now
            
            remaining_capital = max(0.0, capital_allocated - capital_used)
            
            # Get live price
            ticker_price = live_prices.get(ticker, 0.0)
            if ticker_price == 0:
                ticker_positions = df_open[df_open['Ticker'] == ticker]
                if not ticker_positions.empty:
                    price_col = ticker_positions['Price_of_current_underlying_(USD)'].iloc[0]
                    ticker_price = pd.to_numeric(price_col, errors='coerce') or 0.0
            
            # Calculate targets
            if ticker_price > 0:
                daily_capital_target = remaining_capital / 4 / 5
                daily_shares_target = daily_capital_target / ticker_price
                daily_contracts_target = daily_shares_target / 100
                weekly_capital_target = remaining_capital / 4
                weekly_shares_target = weekly_capital_target / ticker_price
                weekly_contracts_target = weekly_shares_target / 100
            else:
                daily_contracts_target = 0.0
                weekly_contracts_target = 0.0
            
            # Get CSP sold this week
            ticker_week = this_week_trades[this_week_trades['Ticker'] == ticker].copy()
            ticker_week['Quantity'] = pd.to_numeric(ticker_week['Quantity'], errors='coerce').fillna(0).abs()
            csp_sold = ticker_week[ticker_week['TradeType'] == 'CSP']['Quantity'].sum() or 0
            
            # Calculate remaining (weekly target - sold this week)
            remaining_weekly = max(0.0, weekly_contracts_target - csp_sold)
            
            csp_data.append({
                'Ticker': ticker,
                'Capital Allocated': f"${capital_allocated:,.0f}",
                'Capital Used': f"${capital_used:,.0f}",
                'Remaining': f"${remaining_capital:,.0f}",
                'Price': f"${ticker_price:.2f}",
                'Weekly Target': f"{weekly_contracts_target:.1f}",
                'Daily Target': f"{daily_contracts_target:.1f}",
                'Sold This Week': f"{int(csp_sold)}",
                'Remaining': f"{remaining_weekly:.1f}"
            })
        
        # Display as table
        if csp_data:
            df_csp = pd.DataFrame(csp_data)
            st.dataframe(
                df_csp,
                use_container_width=True,
                hide_index=True,
                column_config={
                    "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                    "Capital Allocated": st.column_config.TextColumn("Allocated", width="small"),
                    "Capital Used": st.column_config.TextColumn("Used", width="small"),
                    "Remaining": st.column_config.TextColumn("Remaining", width="small"),
                    "Price": st.column_config.TextColumn("Price", width="small"),
                    "Weekly Target": st.column_config.TextColumn("Weekly", width="small"),
                    "Daily Target": st.column_config.TextColumn("Daily", width="small"),
                    "Sold This Week": st.column_config.TextColumn("Sold", width="small"),
                    "Remaining": st.column_config.TextColumn("Remaining", width="small")
                }
            )
    
    with col_right:
        st.markdown("#### üìû CC Selling Target")
        st.caption("Based on stock holdings")
        
        # Prepare CC data for all tickers
        cc_data = []
        for ticker in all_tickers:
            # Get stock holdings
            ticker_inventory = inventory['positions_by_ticker'].get(ticker, {})
            ticker_stock_shares = ticker_inventory.get('total_stock', 0)
            
            # Calculate targets
            ticker_weekly_target = ticker_stock_shares / 4 / 100 if ticker_stock_shares > 0 else 0
            ticker_daily_target = ticker_stock_shares / 4 / 5 / 100 if ticker_stock_shares > 0 else 0
            
            # Get CC sold this week
            ticker_week = this_week_trades[this_week_trades['Ticker'] == ticker].copy()
            ticker_week['Quantity'] = pd.to_numeric(ticker_week['Quantity'], errors='coerce').fillna(0).abs()
            cc_sold = ticker_week[ticker_week['TradeType'] == 'CC']['Quantity'].sum() or 0
            
            # Calculate remaining (weekly target - sold this week)
            remaining_weekly = max(0.0, ticker_weekly_target - cc_sold)
            
            cc_data.append({
                'Ticker': ticker,
                'Stock Held': f"{int(ticker_stock_shares):,}",
                'Weekly Target': f"{ticker_weekly_target:.1f}",
                'Daily Target': f"{ticker_daily_target:.1f}",
                'Sold This Week': f"{int(cc_sold)}",
                'Remaining': f"{remaining_weekly:.1f}"
            })
        
        # Display as table
        if cc_data:
            df_cc = pd.DataFrame(cc_data)
            st.dataframe(
                df_cc,
                use_container_width=True,
                hide_index=True,
                column_config={
                    "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                    "Stock Held": st.column_config.TextColumn("Stock (shares)", width="small"),
                    "Weekly Target": st.column_config.TextColumn("Weekly", width="small"),
                    "Daily Target": st.column_config.TextColumn("Daily", width="small"),
                    "Sold This Week": st.column_config.TextColumn("Sold", width="small"),
                    "Remaining": st.column_config.TextColumn("Remaining", width="small")
                }
            )


def calculate_capital_breakdown(df_open: pd.DataFrame, margin_percentages: dict, live_prices: dict = None) -> dict:
    """
    Calculate capital breakdown by ticker and type
    
    Returns:
        dict with:
            - grid: DataFrame with capital by ticker and type
            - by_trade: dict of {trade_id: {capital, margin_pct, margin_used}}
    """
    import pandas as pd
    
    # Group by ticker and type
    breakdown = {}
    by_trade = {}
    
    for _, row in df_open.iterrows():
        trade_id = row['TradeID']
        ticker = row['Ticker']
        trade_type = row['TradeType']
        
        # Calculate capital for this position
        if trade_type == 'CSP':
            strike = pd.to_numeric(row.get('Option_Strike_Price_(USD)', 0), errors='coerce') or 0
            qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
            capital = strike * 100 * qty
        elif trade_type == 'LEAP':
            # LEAP capital = contract premium paid (OptPremium √ó Quantity)
            # For buying LEAPs, capital is the premium paid for the contracts, not underlying stock value
            # OptPremium is the total premium per contract (not per share), so we don't multiply by 100
            premium = pd.to_numeric(row.get('OptPremium', 0), errors='coerce') or 0
            qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
            # Use absolute value for quantity (long positions)
            if 'Direction' in row and row.get('Direction') == 'Buy':
                qty = abs(qty)
            capital = premium * qty
        elif trade_type == 'STOCK':
            if 'Open_lots' in row and pd.notna(row['Open_lots']):
                shares = abs(pd.to_numeric(row['Open_lots'], errors='coerce') or 0)
            else:
                qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
                shares = abs(qty) * 100
            price = pd.to_numeric(row.get('Price_of_current_underlying_(USD)', 0), errors='coerce')
            # Use live prices as fallback if price is NaN
            if pd.isna(price) or price == 0:
                if live_prices and ticker in live_prices and live_prices[ticker] is not None:
                    price = live_prices[ticker]
                else:
                    price = 0.0
            capital = price * shares
        elif trade_type == 'CC':
            # Check if this CC is part of a PMCC (LEAP + CC for same ticker)
            ticker = row['Ticker']
            ticker_positions = df_open[df_open['Ticker'] == ticker]
            has_leap = (ticker_positions['TradeType'] == 'LEAP').any()
            
            if has_leap:
                # PMCC CC: requires capital (strike * 100 * qty)
                strike = pd.to_numeric(row.get('Option_Strike_Price_(USD)', 0), errors='coerce') or 0
                qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
                capital = strike * 100 * qty
            else:
                # Regular CC: doesn't use capital (covered by stock)
                capital = 0
        else:
            capital = 0
        
        # Get margin % (by ticker_type key: "TICKER_TYPE")
        ticker_type_key = f"{ticker}_{trade_type}"
        if trade_type == 'CC':
            # Check if this CC is part of a PMCC
            ticker_positions = df_open[df_open['Ticker'] == ticker]
            has_leap = (ticker_positions['TradeType'] == 'LEAP').any()
            if has_leap:
                # PMCC CC: can use margin (get from user input)
                margin_pct = margin_percentages.get(ticker_type_key, 0.0)
            else:
                # Regular CC: never uses margin
                margin_pct = 0.0
        else:
            margin_pct = margin_percentages.get(ticker_type_key, 0.0)
        
        margin_used = capital * (margin_pct / 100.0)
        
        # Store by trade
        by_trade[trade_id] = {
            'capital': capital,
            'margin_pct': margin_pct,
            'margin_used': margin_used
        }
        
        # Group by ticker and type
        key = (ticker, trade_type)
        if key not in breakdown:
            breakdown[key] = {
                'Ticker': ticker,
                'Type': trade_type,
                'Capital': 0.0,
                'Margin %': 0.0,
                'Margin Used': 0.0
            }
        
        breakdown[key]['Capital'] += capital
        breakdown[key]['Margin Used'] += margin_used
    
    # Calculate weighted average margin % for each ticker/type combo
    for key, data in breakdown.items():
        if data['Capital'] > 0:
            data['Margin %'] = (data['Margin Used'] / data['Capital']) * 100.0
        else:
            data['Margin %'] = 0.0
    
    # Convert to DataFrame
    grid_data = list(breakdown.values())
    df_grid = pd.DataFrame(grid_data)
    
    # Sort by ticker, then type
    if not df_grid.empty:
        df_grid = df_grid.sort_values(['Ticker', 'Type'])
        # Format columns
        df_grid['Capital'] = df_grid['Capital'].apply(lambda x: f"${x:,.0f}")
        df_grid['Margin %'] = df_grid['Margin %'].apply(lambda x: f"{x:.1f}%")
        df_grid['Margin Used'] = df_grid['Margin Used'].apply(lambda x: f"${x:,.0f}")
    
    return {
        'grid': df_grid,
        'by_trade': by_trade
    }


def calculate_margin_by_position(df_open: pd.DataFrame, margin_percentages: dict, live_prices: dict = None) -> dict:
    """
    Calculate total margin used based on user-entered margin percentages
    
    Returns:
        dict with total_margin_used
    """
    total_margin_used = 0.0
    
    for _, row in df_open.iterrows():
        trade_id = row['TradeID']
        trade_type = row['TradeType']
        
        # CC positions: only PMCC CCs use margin
        if trade_type == 'CC':
            # Check if this CC is part of a PMCC
            ticker = row['Ticker']
            ticker_positions = df_open[df_open['Ticker'] == ticker]
            has_leap = (ticker_positions['TradeType'] == 'LEAP').any()
            if not has_leap:
                # Regular CC (covered by stock): no margin
                continue
            # PMCC CC: continue to calculate margin below
        
        # Calculate capital for this position
        if trade_type == 'CSP':
            strike = pd.to_numeric(row.get('Option_Strike_Price_(USD)', 0), errors='coerce') or 0
            qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
            capital = strike * 100 * qty
        elif trade_type == 'CC':
            # PMCC CC: requires capital (strike * 100 * qty)
            # (Regular CC already filtered out above with continue)
            strike = pd.to_numeric(row.get('Option_Strike_Price_(USD)', 0), errors='coerce') or 0
            qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
            capital = strike * 100 * qty
        elif trade_type == 'LEAP':
            # LEAP capital = contract premium paid (OptPremium √ó Quantity)
            # For buying LEAPs, capital is the premium paid for the contracts, not underlying stock value
            # OptPremium is the total premium per contract (not per share), so we don't multiply by 100
            premium = pd.to_numeric(row.get('OptPremium', 0), errors='coerce') or 0
            qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
            # Use absolute value for quantity (long positions)
            if 'Direction' in row and row.get('Direction') == 'Buy':
                qty = abs(qty)
            capital = premium * qty
        elif trade_type == 'STOCK':
            if 'Open_lots' in row and pd.notna(row['Open_lots']):
                shares = abs(pd.to_numeric(row['Open_lots'], errors='coerce') or 0)
            else:
                qty = pd.to_numeric(row.get('Quantity', 0), errors='coerce') or 0
                shares = abs(qty) * 100
            price = pd.to_numeric(row.get('Price_of_current_underlying_(USD)', 0), errors='coerce')
            # Use live prices as fallback if price is NaN
            if pd.isna(price) or price == 0:
                ticker = row['Ticker']
                if live_prices and ticker in live_prices and live_prices[ticker] is not None:
                    price = live_prices[ticker]
                else:
                    price = 0.0
            capital = price * shares
        else:
            capital = 0
        
        # Get margin % from user input (by ticker_type key: "TICKER_TYPE")
        ticker = row['Ticker']
        ticker_type_key = f"{ticker}_{trade_type}"
        if trade_type == 'CC':
            # PMCC CC: can use margin (get from user input)
            # (Regular CC already filtered out above with continue)
            margin_pct = margin_percentages.get(ticker_type_key, 0.0)
        else:
            margin_pct = margin_percentages.get(ticker_type_key, 0.0)
        margin_used = capital * (margin_pct / 100.0)
        total_margin_used += margin_used
    
    return {
        'total_margin_used': total_margin_used
    }


# ============================================================
# ENTRY FORMS PAGE
# ============================================================
def render_entry_forms():
    """Render trade entry forms"""
    st.title("üìù Entry Forms")
    
    df_open = st.session_state.df_open
    df_trades = st.session_state.df_trades
    df_audit = st.session_state.df_audit
    
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    tickers_for_portfolio = get_tickers_for_dropdown(portfolio, df_trades)
    pmcc_tickers = get_pmcc_tickers(portfolio) if portfolio == "Income Wheel" else []
    pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()

    # Form reset counter ‚Äî incrementing this changes all widget keys so Streamlit
    # treats them as brand-new widgets and renders them with their default values.
    if 'form_reset_counter' not in st.session_state:
        st.session_state.form_reset_counter = 0
    fv = st.session_state.form_reset_counter  # short alias used in widget key= args

    # Helper function to show success and clear form fields
    def show_success_and_clear(trade_id: str = None, form_key: str = "", additional_message: str = ""):
        """Show confirmation popup and reset all forms to defaults after successful submit."""
        if trade_id:
            success_msg = f"‚úÖ Trade submitted {trade_id}"
            if additional_message:
                success_msg += f" - {additional_message}"
        else:
            success_msg = f"‚úÖ {additional_message}" if additional_message else "‚úÖ Recorded successfully."
        st.toast(success_msg, icon="‚úÖ")
        st.success(success_msg)
        st.session_state.success_message = success_msg
        try:
            st.balloons()
        except Exception:
            pass
        # Increment the counter ‚Äî all widget keys change on next render so every
        # widget re-initialises from its declared default value= / index=.
        st.session_state.form_reset_counter += 1
        # Also clear expire_checkboxes dict (not a keyed widget)
        st.session_state.expire_checkboxes = {}
        refresh_data()
        st.rerun()
    
    # Helper function to render strategy selector (for use in each form)
    def render_strategy_selector(form_key_suffix=""):
        """Render strategy selector for a form - returns strategy value. Shown for all portfolios; Active Core defaults to WHEEL."""
        is_active_core = portfolio in ("Active Core", "‚≠ê Active Core")
        default_index = 1 if is_active_core else 0  # WHEEL for Active Core, "‚Äî Select strategy ‚Äî" for Income Wheel
        strategy = st.selectbox(
            "üéØ Strategy",
            ["‚Äî Select strategy ‚Äî", "WHEEL", "PMCC"],
            key=f"entry_strategy_{form_key_suffix}_{fv}",
            index=default_index,
            help="Select strategy: WHEEL (CSP+CC) or PMCC (LEAP+CC)"
        )
        if is_active_core and strategy == "‚Äî Select strategy ‚Äî":
            return "WHEEL"
        return strategy if strategy != "‚Äî Select strategy ‚Äî" else None
    
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs(["Sell CC", "Sell CSP", "BTC", "Roll", "Expire", "Assignment"])
    
    # Get live prices for this portfolio's tickers
    live_prices = get_cached_prices(tuple(tickers_for_portfolio)) if tickers_for_portfolio else {}
    st.session_state.live_prices = live_prices
    
    def display_live_prices_cards():
        """Display live price cards for this portfolio's tickers"""
        if live_prices and tickers_for_portfolio:
            cols = st.columns(min(len(tickers_for_portfolio), 8))
            for idx, ticker in enumerate(tickers_for_portfolio[:8]):
                with cols[idx]:
                    price = live_prices.get(ticker, None)
                    if price is not None:
                        st.metric(ticker, f"${price:.2f}")
                    else:
                        st.metric(ticker, "N/A")
            if len(tickers_for_portfolio) > 8:
                st.caption(f"Showing 8 of {len(tickers_for_portfolio)} tickers.")
            st.divider()
    
    # ---- SELL CC TAB ----
    with tab1:
        st.subheader("Sell Covered Call")
        display_live_prices_cards()
        
        # Input fields (outside form for real-time calculation)
        col1, col2 = st.columns(2)
        
        with col1:
            # Strategy selector right before Ticker
            entry_strategy = render_strategy_selector("cc")
            cc_ticker = st.selectbox("Ticker", ["‚Äî Select ticker ‚Äî"] + list(tickers_for_portfolio), key=f"cc_ticker_{fv}", index=0)
            cc_strike = st.number_input("Strike Price ($)", min_value=0.0, step=0.50, key=f"cc_strike_{fv}", value=0.0)
            cc_expiry = st.date_input("Expiry Date", min_value=date.today(), key=f"cc_expiry_{fv}", value=None)

        with col2:
            cc_qty = st.number_input("Contracts", min_value=0, step=1, key=f"cc_qty_{fv}", value=0)
            cc_premium = st.number_input("Premium ($)", min_value=0.0, step=0.01, key=f"cc_premium_{fv}", value=0.0)
            cc_underlying = st.number_input("Current Stock Price ($)", min_value=0.0, step=0.01, key=f"cc_underlying_{fv}", value=0.0)
        
        # Real-time premium and yield calculation (outside form)
        if cc_ticker and cc_ticker != "‚Äî Select ticker ‚Äî" and cc_premium > 0 and cc_qty > 0 and cc_strike > 0 and cc_expiry:
            total_premium = cc_premium * cc_qty * 100  # Premium per contract * contracts * 100 shares
            premium_pct = (cc_premium / cc_strike) * 100  # Premium as % of strike
            
            # DTE inclusive: today + expiry day both count
            days_to_expiry = (cc_expiry - date.today()).days + 1
            if days_to_expiry > 0:
                # Capital at risk = strike * 100 * qty (for CC, capital is the stock value, but we use strike for yield calc)
                capital_at_risk = cc_strike * 100 * cc_qty
                # Annualized yield = (premium / capital) * (365 / days) * 100
                annualized_yield = (total_premium / capital_at_risk) * (365 / days_to_expiry) * 100
            else:
                annualized_yield = 0
                days_to_expiry = 0
            
            # Display calculations
            st.divider()
            st.write("**üìä Real-time Calculation:**")
            calc_col1, calc_col2, calc_col3, calc_col4 = st.columns(4)
            with calc_col1:
                st.metric("Total Premium", f"${total_premium:,.2f}")
            with calc_col2:
                st.metric("Premium %", f"{premium_pct:.2f}%")
            with calc_col3:
                st.metric("Days to Expiry", f"{days_to_expiry}")
            with calc_col4:
                if days_to_expiry > 0:
                    st.metric("Annualized Yield", f"{annualized_yield:.2f}%")
                else:
                    st.metric("Annualized Yield", "N/A")
            st.divider()
        
        # Comment field
        cc_remarks = st.text_input("Comments (optional)", key=f"cc_remarks_{fv}", placeholder="Enter any comments or notes about this trade")
        
        # Submit button (right after comments)
        submitted = st.button("Submit CC", type="primary", key="cc_submit")
        
        # Show CC Coverage and Pacing Information (consistent with Dashboard and Daily Helper)
        if df_open is not None and not df_open.empty:
            st.divider()
            st.markdown("#### üìä Current Position & Pacing for Selected Ticker")
            
            # Get inventory for this ticker
            inventory = CapitalCalculator.calculate_inventory(df_open)
            ticker_inventory = inventory['positions_by_ticker'].get(cc_ticker, {})
            
            # Stock holdings (STOCK + LEAP)
            stock_shares = ticker_inventory.get('total_stock', 0)
            stock_only = ticker_inventory.get('stock', 0)
            leaps_shares = ticker_inventory.get('leaps', 0)
            
            # Existing CC contracts
            existing_cc = ticker_inventory.get('cc', 0)
            
            # CC Coverage Ratio
            cc_coverage_ratio = ticker_inventory.get('cc_coverage_ratio')
            
            # Calculate required shares for new + existing CCs
            required_shares = (existing_cc + cc_qty) * 100
            
            # Display coverage information
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Stock Held", f"{int(stock_shares):,} shares")
                if leaps_shares > 0:
                    st.caption(f"Stock: {int(stock_only):,} | LEAPs: {int(leaps_shares):,}")
            with col2:
                st.metric("Existing CC", f"{int(existing_cc)} contracts")
                st.caption(f"= {int(existing_cc * 100):,} shares")
            with col3:
                st.metric("New CC", f"{int(cc_qty)} contracts")
                st.caption(f"= {int(cc_qty * 100):,} shares")
            with col4:
                if cc_coverage_ratio is not None:
                    if cc_coverage_ratio < 0:
                        st.metric("CC Coverage", "Uncovered ‚ö†Ô∏è")
                    elif cc_coverage_ratio <= 1.0:
                        # Stock coverage % (CC shares needed / stock shares)
                        coverage_pct = cc_coverage_ratio * 100
                        if coverage_pct >= 100:
                            st.metric("CC Coverage", f"{coverage_pct:.0f}% ‚úÖ")
                        elif coverage_pct >= 80:
                            st.metric("CC Coverage", f"{coverage_pct:.0f}% ‚ö†Ô∏è")
                        else:
                            st.metric("CC Coverage", f"{coverage_pct:.0f}% ‚úÖ")
                    else:
                        # Over 100% means uncovered
                        coverage_pct = cc_coverage_ratio * 100
                        st.metric("CC Coverage", f"{coverage_pct:.0f}% ‚ùå")
                else:
                    st.metric("CC Coverage", "N/A")
            
            # Coverage message (informational only ‚Äì does not block submitting CCs)
            if stock_shares >= required_shares:
                st.success(f"‚úÖ Stock available: {int(stock_shares):,} shares (need {required_shares:,} for {existing_cc + cc_qty} total CCs)")
            else:
                st.warning(f"‚ö†Ô∏è CC ratio over 100%: {int(stock_shares):,} shares (need {required_shares:,} for {existing_cc + cc_qty} total CCs). You can still submit if desired.")
            
            st.divider()
            
            # Show CCs expiring this week for selected ticker
            st.markdown("#### ‚è∞ CCs Expiring This Week")
            today = date.today()
            start_of_week = today - timedelta(days=today.weekday())  # Monday
            end_of_week = start_of_week + timedelta(days=6)  # Sunday
            
            expiring_ccs = df_open[
                (df_open['Ticker'] == cc_ticker) &
                (df_open['TradeType'] == 'CC') &
                (df_open['Status'] == 'Open')
            ].copy()
            
            if not expiring_ccs.empty:
                expiring_ccs['Expiry_Date'] = pd.to_datetime(expiring_ccs['Expiry_Date'], errors='coerce')
                expiring_ccs['Expiry_Date_Date'] = expiring_ccs['Expiry_Date'].dt.date
                
                this_week_ccs = expiring_ccs[
                    (expiring_ccs['Expiry_Date_Date'] >= start_of_week) &
                    (expiring_ccs['Expiry_Date_Date'] <= end_of_week)
                ].copy()
                
                if not this_week_ccs.empty:
                    this_week_ccs['OptPremium'] = pd.to_numeric(this_week_ccs['OptPremium'], errors='coerce').fillna(0)
                    this_week_ccs['Quantity'] = pd.to_numeric(this_week_ccs['Quantity'], errors='coerce').fillna(0)
                    
                    total_expiring_contracts = int(this_week_ccs['Quantity'].sum())
                    avg_premium = this_week_ccs['OptPremium'].mean() if len(this_week_ccs) > 0 else 0.0
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("CCs Expiring This Week", f"{total_expiring_contracts} contracts")
                    with col2:
                        st.metric("Average Premium", f"${avg_premium:.2f}")
                    
                    if total_expiring_contracts > 0:
                        st.info(f"‚ÑπÔ∏è {total_expiring_contracts} CC contract(s) expiring this week may free up {total_expiring_contracts * 100:,} shares, which can help explain coverage above 100% if they're far from spot.")
                else:
                    st.info("‚ÑπÔ∏è No CCs expiring this week for this ticker")
            else:
                st.info("‚ÑπÔ∏è No open CCs for this ticker")
            
            st.divider()
            
            # Show pacing information (from Daily Helper logic)
            st.markdown("#### üéØ Weekly Pacing Information")
            
            # Calculate weekly and daily targets
            ticker_weekly_target = stock_shares / 4 / 100 if stock_shares > 0 else 0
            ticker_daily_target = stock_shares / 4 / 5 / 100 if stock_shares > 0 else 0
            
            # Get CC sold this week
            now = datetime.now()
            start_of_week = now - timedelta(days=now.weekday())
            df_trades_check = st.session_state.df_trades.copy()
            df_trades_check['Date_open'] = pd.to_datetime(df_trades_check['Date_open'], errors='coerce')
            this_week_trades = df_trades_check[
                (df_trades_check['Date_open'] >= start_of_week) &
                (df_trades_check['TradeType'] == 'CC') &
                (df_trades_check['Ticker'] == cc_ticker)
            ].copy()
            this_week_trades['Quantity'] = pd.to_numeric(this_week_trades['Quantity'], errors='coerce').fillna(0).abs()
            cc_sold = this_week_trades['Quantity'].sum() or 0
            
            # Calculate remaining (weekly target - sold this week)
            remaining_weekly = max(0.0, ticker_weekly_target - cc_sold)
            
            # Display pacing metrics
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Weekly Target", f"{ticker_weekly_target:.1f} contracts")
            with col2:
                st.metric("Daily Target", f"{ticker_daily_target:.1f} contracts")
            with col3:
                st.metric("Sold This Week", f"{int(cc_sold)} contracts")
            with col4:
                st.metric("Remaining", f"{remaining_weekly:.1f} contracts")
            
            # Show impact of new trade
            if cc_qty > 0:
                new_total_sold = cc_sold + cc_qty
                new_remaining_weekly = max(0.0, ticker_weekly_target - new_total_sold)
                
                st.info(f"üìà **After this trade:** Total sold this week = {int(new_total_sold)} contracts | Remaining = {new_remaining_weekly:.1f} contracts")
            
            st.divider()
        
        if submitted:
            errs = []
            if not cc_ticker or cc_ticker == "‚Äî Select ticker ‚Äî":
                errs.append("Select a ticker.")
            if not cc_strike or cc_strike <= 0:
                errs.append("Enter strike price.")
            if not cc_qty or cc_qty <= 0:
                errs.append("Enter number of contracts.")
            if not cc_premium or cc_premium <= 0:
                errs.append("Enter premium.")
            if not cc_expiry:
                errs.append("Select expiry date.")
            if not entry_strategy or entry_strategy == "‚Äî Select strategy ‚Äî":
                errs.append("Select a strategy.")
            if errs:
                st.error("Please fix: " + " ".join(errs))
            else:
                # Validate (warnings only ‚Äì never block on insufficient stock / CC ratio > 100%)
                valid, msg = TradeValidator.validate_sell_cc(cc_ticker, cc_qty, df_open)
                if valid and "WARNING" in msg:
                    st.warning(msg)
                elif not valid:
                    # Do not block on stock/coverage; allow submit and show warning only
                    if msg and ("insufficient" in msg.lower() or "stock" in msg.lower() or "shares" in msg.lower() or "coverage" in msg.lower()):
                        st.warning(f"‚ö†Ô∏è {msg}")
                        valid = True
                    else:
                        st.error(f"‚ùå Validation failed: {msg}")
                if valid:
                    new_trade_id = generate_trade_id(df_trades)
                    strategy_cc = entry_strategy or "WHEEL"
                    trade_data = {
                        'TradeID': new_trade_id,
                        'Ticker': cc_ticker,
                        'StrategyType': strategy_cc,
                        'Direction': 'Sell',
                        'TradeType': 'CC',
                        'Quantity': cc_qty,
                        'Option_Strike_Price_(USD)': cc_strike,
                        'Price_of_current_underlying_(USD)': cc_underlying,
                        'OptPremium': cc_premium,
                        'Opt_Premium_%': (cc_premium / cc_strike) if cc_strike else 0,
                        'Date_open': datetime.now(),
                        'Expiry_Date': cc_expiry,
                        'Remarks': cc_remarks,
                        'Status': 'Open',
                        'Open_lots': cc_qty * 100
                    }
                    
                    audit_data = {
                        'Audit ID': generate_audit_id(st.session_state.df_audit),
                        'TImeStamp': datetime.now(),
                        'Action Type': 'Open',
                        'TradeID_Ref': new_trade_id,
                        'Remarks': f'Sell CC {cc_ticker} ${cc_strike} x{cc_qty}',
                        'ScriptNAme': 'Income Wheel App',
                        'AffectedQty': cc_qty
                    }
                    
                    try:
                        handler = ExcelHandler(str(st.session_state.current_data_file))
                        handler.append_trade(trade_data)  # Write to main Data Table
                        handler.append_audit(audit_data)  # Write to Audit Table
                        show_success_and_clear(new_trade_id, 'cc')
                    except Exception as e:
                        st.error(f"‚ùå Error saving trade: {e}")
                        st.error("‚ö†Ô∏è Trade was NOT saved. Please try again.")
    
    # ---- SELL CSP TAB ----
    with tab2:
        st.subheader("Sell Cash-Secured Put")
        display_live_prices_cards()
        
        # Input fields (outside form for real-time calculation)
        col1, col2 = st.columns(2)
        
        with col1:
            # Strategy selector right before Ticker
            entry_strategy = render_strategy_selector("csp")
            csp_ticker = st.selectbox("Ticker", ["‚Äî Select ticker ‚Äî"] + list(tickers_for_portfolio), key=f"csp_ticker_{fv}", index=0)
            # Auto-detect strategy for PMCC tickers
            if portfolio == "Income Wheel" and csp_ticker and csp_ticker != "‚Äî Select ticker ‚Äî":
                pmcc_tickers = get_pmcc_tickers(portfolio)
                pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
                if csp_ticker in pmcc_tickers_set:
                    st.warning(f"‚ö†Ô∏è {csp_ticker} is a PMCC ticker - CSPs are typically not used in PMCC strategy")
            csp_strike = st.number_input("Strike Price ($)", min_value=0.0, step=0.50, key=f"csp_strike_{fv}", value=0.0)
            csp_expiry = st.date_input("Expiry Date", min_value=date.today(), key=f"csp_expiry_{fv}", value=None)

        with col2:
            csp_qty = st.number_input("Contracts", min_value=0, step=1, key=f"csp_qty_{fv}", value=0)
            csp_premium = st.number_input("Premium ($)", min_value=0.0, step=0.01, key=f"csp_premium_{fv}", value=0.0)
            csp_underlying = st.number_input("Current Stock Price ($)", min_value=0.0, step=0.01, key=f"csp_underlying_{fv}", value=0.0)
        
        # Show cash required
        cash_required = csp_strike * 100 * csp_qty
        st.info(f"üíµ Cash Required: ${cash_required:,.0f}")
        
        # Real-time premium and yield calculation (outside form)
        if csp_ticker and csp_ticker != "‚Äî Select ticker ‚Äî" and csp_premium > 0 and csp_qty > 0 and csp_strike > 0 and csp_expiry:
            total_premium = csp_premium * csp_qty * 100  # Premium per contract * contracts * 100 shares
            premium_pct = (csp_premium / csp_strike) * 100  # Premium as % of strike
            
            # DTE inclusive: today + expiry day both count
            days_to_expiry = (csp_expiry - date.today()).days + 1
            if days_to_expiry > 0:
                # Capital at risk = strike * 100 * qty (cash secured)
                capital_at_risk = csp_strike * 100 * csp_qty
                # Annualized yield = (premium / capital) * (365 / days) * 100
                annualized_yield = (total_premium / capital_at_risk) * (365 / days_to_expiry) * 100
            else:
                annualized_yield = 0
                days_to_expiry = 0
            
            # Display calculations
            st.divider()
            st.write("**üìä Real-time Calculation:**")
            calc_col1, calc_col2, calc_col3, calc_col4 = st.columns(4)
            with calc_col1:
                st.metric("Total Premium", f"${total_premium:,.2f}")
            with calc_col2:
                st.metric("Premium %", f"{premium_pct:.2f}%")
            with calc_col3:
                st.metric("Days to Expiry", f"{days_to_expiry}")
            with calc_col4:
                if days_to_expiry > 0:
                    st.metric("Annualized Yield", f"{annualized_yield:.2f}%")
                else:
                    st.metric("Annualized Yield", "N/A")
            st.divider()
        
        csp_remarks = st.text_input("Remarks (optional)", key=f"csp_remarks_{fv}")
        
        # Show CSPs expiring this week for selected ticker
        if df_open is not None and not df_open.empty:
            st.divider()
            st.markdown("#### ‚è∞ CSPs Expiring This Week")
            today = date.today()
            start_of_week = today - timedelta(days=today.weekday())  # Monday
            end_of_week = start_of_week + timedelta(days=6)  # Sunday
            
            expiring_csps = df_open[
                (df_open['Ticker'] == csp_ticker) &
                (df_open['TradeType'] == 'CSP') &
                (df_open['Status'] == 'Open')
            ].copy()
            
            if not expiring_csps.empty:
                expiring_csps['Expiry_Date'] = pd.to_datetime(expiring_csps['Expiry_Date'], errors='coerce')
                expiring_csps['Expiry_Date_Date'] = expiring_csps['Expiry_Date'].dt.date
                
                this_week_csps = expiring_csps[
                    (expiring_csps['Expiry_Date_Date'] >= start_of_week) &
                    (expiring_csps['Expiry_Date_Date'] <= end_of_week)
                ].copy()
                
                if not this_week_csps.empty:
                    this_week_csps['OptPremium'] = pd.to_numeric(this_week_csps['OptPremium'], errors='coerce').fillna(0)
                    this_week_csps['Quantity'] = pd.to_numeric(this_week_csps['Quantity'], errors='coerce').fillna(0)
                    this_week_csps['Option_Strike_Price_(USD)'] = pd.to_numeric(this_week_csps['Option_Strike_Price_(USD)'], errors='coerce').fillna(0)
                    
                    total_expiring_contracts = int(this_week_csps['Quantity'].sum())
                    avg_premium = this_week_csps['OptPremium'].mean() if len(this_week_csps) > 0 else 0.0
                    
                    # Calculate total capital that will be freed up (strike * quantity * 100 for each position)
                    total_capital_freed = (this_week_csps['Option_Strike_Price_(USD)'] * this_week_csps['Quantity'] * 100).sum()
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("CSPs Expiring This Week", f"{total_expiring_contracts} contracts")
                    with col2:
                        st.metric("Average Premium", f"${avg_premium:.2f}")
                    
                    if total_expiring_contracts > 0:
                        st.info(f"‚ÑπÔ∏è {total_expiring_contracts} CSP contract(s) expiring this week may free up ${total_capital_freed:,.0f} in capital, which can help explain capital allocation if they're far from spot.")
                else:
                    st.info("‚ÑπÔ∏è No CSPs expiring this week for this ticker")
            else:
                st.info("‚ÑπÔ∏è No open CSPs for this ticker")
            
            st.divider()
        
        # Submit button
        submitted = st.button("Submit CSP", type="primary", key="csp_submit")
            
        if submitted:
            errs = []
            if not csp_ticker or csp_ticker == "‚Äî Select ticker ‚Äî":
                errs.append("Select a ticker.")
            if not csp_strike or csp_strike <= 0:
                errs.append("Enter strike price.")
            if not csp_qty or csp_qty <= 0:
                errs.append("Enter number of contracts.")
            if not csp_premium or csp_premium <= 0:
                errs.append("Enter premium.")
            if not csp_expiry:
                errs.append("Select expiry date.")
            if not entry_strategy or entry_strategy == "‚Äî Select strategy ‚Äî":
                errs.append("Select a strategy.")
            if errs:
                st.error("Please fix: " + " ".join(errs))
            else:
                new_trade_id = generate_trade_id(df_trades)
                strategy_csp = entry_strategy or "WHEEL"
                trade_data = {
                    'TradeID': new_trade_id,
                    'Ticker': csp_ticker,
                    'StrategyType': strategy_csp,
                    'Direction': 'Sell',
                    'TradeType': 'CSP',
                    'Quantity': csp_qty,
                    'Option_Strike_Price_(USD)': csp_strike,
                    'Price_of_current_underlying_(USD)': csp_underlying,
                    'OptPremium': csp_premium,
                    'Opt_Premium_%': (csp_premium / csp_strike) if csp_strike else 0,
                    'Date_open': datetime.now(),
                    'Expiry_Date': csp_expiry,
                    'Remarks': csp_remarks,
                    'Status': 'Open',
                    'Cash_required_per_position_(USD)': cash_required,
                    'Open_lots': csp_qty * 100
                }
                audit_data = {
                    'Audit ID': generate_audit_id(st.session_state.df_audit),
                    'TImeStamp': datetime.now(),
                    'Action Type': 'Open',
                    'TradeID_Ref': new_trade_id,
                    'Remarks': f'Sell CSP {csp_ticker} ${csp_strike} x{csp_qty}',
                    'ScriptNAme': 'Income Wheel App',
                    'AffectedQty': csp_qty
                }
                try:
                    handler = ExcelHandler(str(st.session_state.current_data_file))
                    handler.append_trade(trade_data)  # Write to main Data Table
                    handler.append_audit(audit_data)  # Write to Audit Table
                    show_success_and_clear(new_trade_id, 'csp')
                except Exception as e:
                    st.error(f"‚ùå Error saving trade: {e}")
                    st.error("‚ö†Ô∏è Trade was NOT saved. Please try again.")
    
    # ---- BTC TAB ----
    with tab3:
        st.subheader("Buy to Close (BTC)")
        display_live_prices_cards()
        
        # Strategy selector (for reference, but BTC uses original trade's strategy)
        entry_strategy = render_strategy_selector("btc")
        
        if df_open is None or df_open.empty:
            st.warning("No open positions to close")
        else:
            # Filter to CC and CSP only
            open_options = df_open[df_open['TradeType'].isin(['CC', 'CSP'])].copy()
            
            if open_options.empty:
                st.warning("No open CC/CSP positions to close")
            else:
                # Normalize Expiry_Date for filtering
                open_options['_expiry_d'] = pd.to_datetime(open_options['Expiry_Date'], errors='coerce').dt.date
                open_options['_expiry_str'] = open_options['_expiry_d'].astype(str)
                open_options['_qty'] = pd.to_numeric(open_options['Quantity'], errors='coerce').fillna(0).astype(int)
                
                # ---- Filters: Ticker, Expiry Date, Type, Quantity ----
                st.markdown("**üîç Filter positions**")
                fcol1, fcol2, fcol3, fcol4 = st.columns(4)
                tickers_btc = ["‚Äî Select ‚Äî"] + sorted(open_options['Ticker'].dropna().unique().tolist())
                expiries_btc = ["‚Äî Select ‚Äî"] + sorted(open_options['_expiry_str'].dropna().unique().tolist())
                with fcol1:
                    filter_ticker_btc = st.selectbox("Ticker", tickers_btc, key=f"btc_filter_ticker_{fv}", index=0)
                with fcol2:
                    filter_expiry_btc = st.selectbox("Expiry Date", expiries_btc, key=f"btc_filter_expiry_{fv}", index=0)
                with fcol3:
                    filter_type_btc = st.selectbox("Type", ["‚Äî Select ‚Äî", "CC", "CSP"], key=f"btc_filter_type_{fv}", index=0)
                with fcol4:
                    qty_options = ["‚Äî Select ‚Äî"] + ["1", "2", "3", "4", "5+"]
                    filter_qty_btc = st.selectbox("Quantity", qty_options, key=f"btc_filter_qty_{fv}", index=0)
                
                filtered_btc = open_options.copy()
                if filter_ticker_btc and filter_ticker_btc != "‚Äî Select ‚Äî":
                    filtered_btc = filtered_btc[filtered_btc['Ticker'] == filter_ticker_btc]
                if filter_expiry_btc and filter_expiry_btc != "‚Äî Select ‚Äî":
                    filtered_btc = filtered_btc[filtered_btc['_expiry_str'] == filter_expiry_btc]
                if filter_type_btc and filter_type_btc != "‚Äî Select ‚Äî":
                    filtered_btc = filtered_btc[filtered_btc['TradeType'] == filter_type_btc]
                if filter_qty_btc and filter_qty_btc != "‚Äî Select ‚Äî":
                    if filter_qty_btc == "5+":
                        filtered_btc = filtered_btc[filtered_btc['_qty'] >= 5]
                    else:
                        qty_val = int(filter_qty_btc)
                        filtered_btc = filtered_btc[filtered_btc['_qty'] == qty_val]
                
                if filtered_btc.empty:
                    st.warning("No positions match the selected filters. Adjust filters or choose '‚Äî Select ‚Äî'.")
                else:
                    # Position selector OUTSIDE form so changing it triggers rerun and Close Qty gets correct max (1..quantity)
                    position_options = ["‚Äî Select position ‚Äî"] + filtered_btc.apply(
                        lambda r: f"{r['TradeID']} - {r['TradeType']} {r['Ticker']} ${r['Option_Strike_Price_(USD)']} ({r['Quantity']} contracts)",
                        axis=1
                    ).tolist()
                    selected = st.selectbox("Select Position to Close", position_options, index=0, key=f"btc_position_select_{fv}")
                    
                    quantity = 0
                    trade_id = None
                    original = None
                    if selected and selected != "‚Äî Select position ‚Äî":
                        trade_id = selected.split(' - ')[0].strip()
                        match = filtered_btc[filtered_btc['TradeID'].astype(str).str.strip() == trade_id]
                        if not match.empty:
                            original = match.iloc[0]
                            quantity = int(pd.to_numeric(original['Quantity'], errors='coerce') or 0)
                            quantity = max(1, quantity)
                    btc_close_qty_key = f"btc_close_qty_{fv}"
                    if quantity >= 1 and btc_close_qty_key in st.session_state:
                        old_q = st.session_state[btc_close_qty_key]
                        if old_q is None or old_q < 1 or old_q > quantity:
                            st.session_state[btc_close_qty_key] = quantity

                    max_close = quantity if quantity >= 1 else 1
                    default_close = quantity if quantity >= 1 else 1

                    with st.form(f"btc_form_{fv}"):
                        st.markdown("**Enter BTC details**")
                        col_btc1, col_btc2 = st.columns(2)
                        with col_btc1:
                            close_qty = st.number_input(
                                "Close Qty (contracts)",
                                min_value=1,
                                max_value=max_close,
                                value=default_close,
                                step=1,
                                key=f"btc_close_qty_{fv}",
                                help="Choose how many contracts to close (1 to %s for this position)." % max_close
                            )
                        with col_btc2:
                            btc_price = st.number_input("BTC Price (per contract, $)", min_value=0.0, step=0.01, key=f"btc_price_{fv}")

                        is_partial_choice = False
                        if quantity > 0 and close_qty < quantity:
                            is_partial_choice = st.checkbox(
                                "Partial close ‚Äî split into (A) closed and (B) open",
                                key=f"btc_partial_confirm_{fv}",
                                help="Check to split: closed part (A) and open part (B)."
                            )
                        
                        if original is not None:
                            st.write(f"**Original Premium:** ${original['OptPremium']:.2f} ¬∑ **Position Qty:** {quantity} contract(s)")
                            original_premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                            profit = (original_premium - btc_price) * 100 * close_qty
                            if btc_price > 0:
                                if profit >= 0:
                                    st.success(f"üí∞ P&L (this close): ${profit:,.2f}")
                                else:
                                    st.error(f"üìâ P&L (this close): ${profit:,.2f}")
                                st.caption(f"Formula: (${original_premium:.2f} - ${btc_price:.2f}) √ó 100 √ó {close_qty} = ${profit:,.2f}")
                            if close_qty < quantity and not is_partial_choice:
                                st.warning(f"Close qty ({close_qty}) < position ({quantity}). Check **Partial close** to split, or set Close Qty to {quantity} for full close.")
                            elif close_qty == quantity:
                                st.info("Full close ‚Äî entire position will be closed (no split).")
                        else:
                            st.caption("Select a position above, then enter Close Qty and BTC Price.")
                        
                        submitted = st.form_submit_button("Close Position (BTC)", type="primary")
                    
                    if submitted:
                        if not selected or selected == "‚Äî Select position ‚Äî" or trade_id is None or original is None:
                            st.error("Please select a position to close.")
                        else:
                            valid, msg = TradeValidator.validate_btc(trade_id, df_open)
                            if not valid:
                                st.error(f"‚ùå {msg}")
                            else:
                                quantity = int(pd.to_numeric(original['Quantity'], errors='coerce') or 0)
                                close_qty = int(close_qty) if close_qty is not None else quantity
                                close_qty = min(max(1, close_qty), quantity)
                                remaining_qty = quantity - close_qty
                                original_premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                                profit = (original_premium - btc_price) * 100 * close_qty
                                
                                # Full close: close_qty == quantity ‚Üí no split, no (A)/(B)
                                # Partial close: close_qty < quantity and user must have confirmed with checkbox
                                if remaining_qty > 0 and not st.session_state.get("btc_partial_confirm", False):
                                    st.error("Close Qty is less than position size. Check **Partial close ‚Äî split into (A) closed and (B) open** to proceed, or set Close Qty to the full position size for a full close.")
                                else:
                                    is_partial = remaining_qty > 0
                                    audit_data = {
                                        'Audit ID': generate_audit_id(st.session_state.df_audit),
                                        'TImeStamp': datetime.now(),
                                        'Action Type': 'BTC',
                                        'TradeID_Ref': trade_id,
                                        'Remarks': f'BTC at ${btc_price:.2f}, P&L: ${profit:.2f}' + (f' (partial: {close_qty}/{quantity})' if is_partial else ''),
                                        'ScriptNAme': 'Income Wheel App',
                                        'AffectedQty': close_qty
                                    }
                                    try:
                                        handler = ExcelHandler(str(st.session_state.current_data_file))
                                        if is_partial:
                                            # Partial: rename to (A) closed, create (B) open
                                            trade_id_a = f"{trade_id}(A)"
                                            trade_id_b = f"{trade_id}(B)"
                                            audit_data['TradeID_Ref'] = f"{trade_id_a}, {trade_id_b}"
                                            updates_a = {
                                                'TradeID': trade_id_a,
                                                'Quantity': close_qty,
                                                'Open_lots': close_qty * 100,
                                                'Status': 'Closed',
                                                'Date_closed': datetime.now(),
                                                'Close_Price': btc_price,
                                                'Actual_Profit_(USD)': profit
                                            }
                                            handler.update_trade(trade_id, updates_a)
                                            row_b = original.to_dict()
                                            for k in list(row_b.keys()):
                                                if k.startswith('_'):
                                                    del row_b[k]
                                            row_b['TradeID'] = trade_id_b
                                            row_b['Quantity'] = remaining_qty
                                            row_b['Open_lots'] = remaining_qty * 100
                                            row_b['Status'] = 'Open'
                                            row_b.pop('Date_closed', None)
                                            row_b.pop('Close_Price', None)
                                            row_b.pop('Actual_Profit_(USD)', None)
                                            if 'Date_open' in row_b and pd.isna(row_b.get('Date_open')):
                                                row_b['Date_open'] = original.get('Date_open')
                                            handler.append_trade(row_b)
                                            show_success_and_clear(trade_id_a, 'btc', f"Closed {trade_id_a}; {trade_id_b} open with {remaining_qty} contract(s)")
                                        else:
                                            # Full close: keep TradeID, just close the position
                                            updates = {
                                                'Status': 'Closed',
                                                'Date_closed': datetime.now(),
                                                'Close_Price': btc_price,
                                                'Actual_Profit_(USD)': profit
                                            }
                                            handler.update_trade(trade_id, updates)
                                            show_success_and_clear(trade_id, 'btc', f"Full close: {trade_id}")
                                        handler.append_audit(audit_data)
                                    except Exception as e:
                                        st.error(f"‚ùå Error saving trade: {e}")
                                        st.error("‚ö†Ô∏è Trade was NOT saved. Please try again.")
    
    # ---- ROLL TAB ----
    with tab4:
        st.subheader("Roll Position")
        display_live_prices_cards()
        
        if df_open is None or df_open.empty:
            st.warning("No open positions to roll")
        else:
            open_options = df_open[df_open['TradeType'].isin(['CC', 'CSP'])].copy()
            
            if open_options.empty:
                st.warning("No open CC/CSP positions to roll")
            else:
                # Normalize Expiry_Date for filtering (may be datetime or string)
                open_options['_expiry_d'] = pd.to_datetime(open_options['Expiry_Date'], errors='coerce').dt.date
                open_options['_expiry_str'] = open_options['_expiry_d'].astype(str)
                
                # ---- Filters: Ticker, Option Type, Expiry Date (dropdowns) ----
                st.markdown("**üîç Filter positions available for roll**")
                fcol1, fcol2, fcol3 = st.columns(3)
                tickers_available = ["‚Äî Select ‚Äî"] + sorted(open_options['Ticker'].dropna().unique().tolist())
                expiries_available = ["‚Äî Select ‚Äî"] + sorted(open_options['_expiry_str'].dropna().unique().tolist())
                
                with fcol1:
                    filter_ticker = st.selectbox("Ticker", tickers_available, key=f"roll_filter_ticker_{fv}", index=0)
                with fcol2:
                    filter_type = st.selectbox("Option Type", ["‚Äî Select ‚Äî", "CC", "CSP"], key=f"roll_filter_type_{fv}", index=0)
                with fcol3:
                    filter_expiry = st.selectbox("Expiry Date", expiries_available, key=f"roll_filter_expiry_{fv}", index=0)
                
                # Apply filters (only when user chose something other than placeholder)
                filtered = open_options.copy()
                if filter_ticker and filter_ticker != "‚Äî Select ‚Äî":
                    filtered = filtered[filtered['Ticker'] == filter_ticker]
                if filter_type and filter_type != "‚Äî Select ‚Äî":
                    filtered = filtered[filtered['TradeType'] == filter_type]
                if filter_expiry and filter_expiry != "‚Äî Select ‚Äî":
                    filtered = filtered[filtered['_expiry_str'] == filter_expiry]
                
                if filtered.empty:
                    st.warning("No positions match the selected filters. Adjust filters or choose 'All'.")
                else:
                    # Strategy selector
                    entry_strategy = render_strategy_selector("roll")
                    # Select position to roll (from filtered list); blank default
                    position_options = ["‚Äî Select position ‚Äî"] + filtered.apply(
                        lambda r: f"{r['TradeID']} - {r['TradeType']} {r['Ticker']} ${r['Option_Strike_Price_(USD)']} exp {r['_expiry_str']}",
                        axis=1
                    ).tolist()
                    selected = st.selectbox("Select Position to Roll", position_options, key=f"roll_position_select_{fv}", index=0)
                    if selected and selected != "‚Äî Select position ‚Äî":
                        old_trade_id = selected.split(' - ')[0]
                        original = filtered[filtered['TradeID'] == old_trade_id].iloc[0]
                        quantity = int(pd.to_numeric(original['Quantity'], errors='coerce') or 0)
                        original_premium = float(pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0)
                        orig_strike = float(original['Option_Strike_Price_(USD)'])
                        st.write(f"**Rolling:** {original['TradeType']} {original['Ticker']}")
                        st.write(f"**Current Strike:** ${orig_strike:.2f}")
                        st.write(f"**Current Expiry:** {original['_expiry_str']}")
                        st.write(f"**Quantity:** {quantity} contract(s)")
                        st.divider()
                        col1, col2 = st.columns(2)
                        with col1:
                            new_strike = st.number_input("New Strike ($)", min_value=0.0, step=0.50, key=f"roll_new_strike_{fv}", value=0.0)
                            new_expiry = st.date_input("New Expiry", min_value=date.today(), key=f"roll_new_expiry_{fv}", value=None)
                        with col2:
                            btc_cost = st.number_input("BTC Cost (to close old, $)", min_value=0.0, step=0.01, key=f"roll_btc_cost_{fv}", value=0.0)
                            new_premium = st.number_input("New Premium ($)", min_value=0.0, step=0.01, key=f"roll_new_premium_{fv}", value=0.0)
                        quantity_to_roll = st.number_input(
                            "Quantity to roll (contracts)",
                            min_value=0,
                            max_value=max(1, quantity),
                            value=0,
                            step=1,
                            key=f"roll_quantity_{fv}"
                        )
                        old_position_profit = (original_premium - btc_cost) * 100 * quantity_to_roll
                        total_premium_received = original_premium * 100 * quantity_to_roll
                        # Net Credit/Debit = original premium + new premium - cost to close (includes all cash flows)
                        net_credit = (original_premium + new_premium - btc_cost) * 100 * quantity_to_roll
                        st.divider()
                        st.markdown("#### üìä Roll Calculations (live)")
                        st.markdown("**üí∞ Premium Received (P&L):**")
                        col_prem1, col_prem2, col_prem3 = st.columns(3)
                        with col_prem1:
                            st.metric("Old Premium Received", f"${original_premium:.2f}")
                        with col_prem2:
                            st.metric("Quantity", f"{quantity_to_roll} contract(s)")
                        with col_prem3:
                            st.metric("**Total Premium Received**", f"**${total_premium_received:,.2f}**")
                        st.caption(f"Premium received when sold: ${original_premium:.2f} √ó 100 √ó {quantity_to_roll} = ${total_premium_received:,.2f}")
                        col1, col2 = st.columns(2)
                        with col1:
                            st.markdown("**Old Position P&L (Being Closed):**")
                            if old_position_profit >= 0:
                                st.success(f"üí∞ Profit: ${old_position_profit:,.2f}")
                            else:
                                st.error(f"üìâ Loss: ${old_position_profit:,.2f}")
                            st.caption(f"Formula: (${original_premium:.2f} received - ${btc_cost:.2f} paid) √ó 100 √ó {quantity_to_roll} = ${old_position_profit:,.2f}")
                            st.info(f"‚úÖ This P&L (${old_position_profit:,.2f}) will be recorded as **Actual_Profit_(USD)** on the old position.")
                        with col2:
                            st.markdown("**Net Credit/Debit from Roll:**")
                            if net_credit >= 0:
                                st.success(f"üíµ Net Credit: ${net_credit:,.2f}")
                            else:
                                st.warning(f"üí∏ Net Debit: ${abs(net_credit):,.2f}")
                            st.caption(f"Formula: (${original_premium:.2f} orig + ${new_premium:.2f} new ‚àí ${btc_cost:.2f} close) √ó 100 √ó {quantity_to_roll} = ${net_credit:,.2f}")
                            st.info("üí° Original premium received + new premium ‚àí cost to close old = net credit/debit.")
                        submitted = st.button("Execute Roll", type="primary", key="roll_submit_btn")
                    else:
                        st.caption("Select a position above to roll.")
                        submitted = False
                
                if submitted and not filtered.empty and selected and selected != "‚Äî Select position ‚Äî":
                        roll_errs = []
                        if not new_strike or new_strike <= 0:
                            roll_errs.append("Enter new strike.")
                        if not new_expiry:
                            roll_errs.append("Select new expiry.")
                        if new_premium is None or new_premium < 0:
                            roll_errs.append("Enter new premium.")
                        if not quantity_to_roll or quantity_to_roll < 1:
                            roll_errs.append("Enter quantity to roll (at least 1).")
                        if roll_errs:
                            st.error("Please fix: " + " ".join(roll_errs))
                        else:
                            valid, msg = TradeValidator.validate_roll(old_trade_id, new_expiry, df_open)
                            if not valid:
                                st.error(f"‚ùå {msg}")
                            else:
                                new_trade_id = generate_trade_id(df_trades)
                                _qty_save = int(pd.to_numeric(original['Quantity'], errors='coerce') or 0)
                                _orig_prem = float(pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0)
                                old_position_profit = (_orig_prem - btc_cost) * 100 * _qty_save
                                net_credit_save = (_orig_prem + new_premium - btc_cost) * 100 * _qty_save
                                old_updates = {
                                    'Status': 'Closed',
                                    'Date_closed': datetime.now(),
                                    'Close_Price': btc_cost,
                                    'Actual_Profit_(USD)': old_position_profit,
                                    'Remarks': f"Rolled to {new_trade_id}"
                                }
                                orig_strat = original.get('StrategyType') or entry_strategy or 'WHEEL'
                                if orig_strat == "‚Äî Select strategy ‚Äî":
                                    orig_strat = 'WHEEL'
                                new_trade = {
                                'TradeID': new_trade_id,
                                'Ticker': original['Ticker'],
                                'StrategyType': orig_strat,
                                'Direction': 'Sell',
                                'TradeType': original['TradeType'],
                                'Quantity': original['Quantity'],
                                'Option_Strike_Price_(USD)': new_strike,
                                'Price_of_current_underlying_(USD)': original['Price_of_current_underlying_(USD)'],
                                'OptPremium': new_premium,
                                'Date_open': datetime.now(),
                                'Expiry_Date': new_expiry,
                                'Status': 'Open',
                                'Remarks': f"Rolled from {old_trade_id}",
                                'Open_lots': original['Quantity'] * 100
                            }
                            
                            audit_data = {
                                'Audit ID': generate_audit_id(st.session_state.df_audit),
                                'TImeStamp': datetime.now(),
                                'Action Type': 'Roll',
                                'TradeID_Ref': f"{old_trade_id}, {new_trade_id}",
                                'Remarks': f"Net credit: ${net_credit_save:.2f}",
                                'ScriptNAme': 'Income Wheel App',
                                'AffectedQty': _qty_save
                            }
                            
                            try:
                                handler = ExcelHandler(str(st.session_state.current_data_file))
                                handler.update_trade(old_trade_id, old_updates)  # Update old position in Data Table
                                handler.append_trade(new_trade)  # Add new position to Data Table
                                handler.append_audit(audit_data)  # Write to Audit Table
                                show_success_and_clear(new_trade_id, 'roll', f"Rolled from {old_trade_id}")
                            except Exception as e:
                                st.error(f"‚ùå Error saving trade: {e}")
                                st.error("‚ö†Ô∏è Trade was NOT saved. Please try again.")
    
    # ---- EXPIRE TAB ----
    with tab5:
        st.subheader("Expire Options (Worthless)")
        display_live_prices_cards()
        st.info("üí° Use this for options expiring worthless (both CC and CSP). Options will be closed at $0.00 and full premium recorded as profit. No stock positions are created or closed.")
        
        # Strategy selector at top
        entry_strategy = render_strategy_selector("expire")
        
        if df_open is None or df_open.empty:
            st.warning("No open positions")
        else:
            # Filter to ONLY OPEN options expiring in past 30 days and next 15 days
            today = date.today()
            thirty_days_ago = today - timedelta(days=30)
            fifteen_days_later = today + timedelta(days=15)
            
            # Explicitly filter for OPEN status and CC/CSP types
            open_options = df_open[
                (df_open['Status'].str.upper() == 'OPEN') &
                (df_open['TradeType'].isin(['CC', 'CSP']))
            ].copy()
            
            if open_options.empty:
                st.warning("No open option positions found")
            else:
                # Convert expiry dates
                open_options['Expiry_Date'] = pd.to_datetime(open_options['Expiry_Date'], errors='coerce')
                open_options['Expiry_Date_Date'] = open_options['Expiry_Date'].dt.date
                
                # Filter to options expiring in past 30 days and next 15 days
                expiring_options = open_options[
                    (open_options['Expiry_Date_Date'] >= thirty_days_ago) &
                    (open_options['Expiry_Date_Date'] <= fifteen_days_later) &
                    (open_options['Expiry_Date_Date'].notna())
                ].copy()
                
                if expiring_options.empty:
                    st.warning("No open options expiring in the past 30 days or next 15 days")
                else:
                    # Sort by ticker, then expiry date
                    expiring_options = expiring_options.sort_values(['Ticker', 'Expiry_Date_Date'])
                    
                    # Initialize session state for checkboxes if not exists
                    if 'expire_checkboxes' not in st.session_state:
                        st.session_state.expire_checkboxes = {}
                    
                    st.markdown("#### Options Expiring (Past 30 Days & Next 15 Days) - Open Positions Only")
                    st.caption("Select options that will expire worthless. Total premium will be calculated automatically.")
                    
                    # Group by ticker for better display
                    tickers_expiring = sorted(expiring_options['Ticker'].unique().tolist())
                    
                    for ticker in tickers_expiring:
                        ticker_positions = expiring_options[expiring_options['Ticker'] == ticker].copy()
                        
                        st.markdown(f"**{ticker}**")
                        
                        # Create table for this ticker
                        display_data = []
                        for _, row in ticker_positions.iterrows():
                            trade_id = row['TradeID']
                            expiry_date = row['Expiry_Date_Date']
                            # DTE inclusive: today + expiry day both count
                            dte = (expiry_date - today).days + 1
                            premium = pd.to_numeric(row['OptPremium'], errors='coerce') or 0.0
                            quantity = int(row['Quantity'])
                            full_premium = premium * quantity * 100
                            
                            # Format DTE (negative = past expiry, positive = future)
                            if dte < 0:
                                dte_str = f"-{abs(dte)}d (Past)"
                            elif dte == 0:
                                dte_str = "Today"
                            else:
                                dte_str = f"{dte}d"
                            
                            # Get checkbox state
                            checkbox_key = f"expire_{trade_id}"
                            is_selected = st.session_state.expire_checkboxes.get(trade_id, False)
                            
                            display_data.append({
                                'Select': is_selected,
                                'TradeID': trade_id,
                                'Type': row['TradeType'],
                                'Strike': f"${row['Option_Strike_Price_(USD)']:.2f}",
                                'Quantity': quantity,
                                'Expiry': expiry_date.strftime('%Y-%m-%d'),
                                'DTE': dte_str,
                                'Premium/Contract': f"${premium:.2f}",
                                'Total Premium': f"${full_premium:,.2f}"
                            })
                        
                        df_ticker = pd.DataFrame(display_data)
                        
                        # Display with checkboxes
                        for idx, row_data in df_ticker.iterrows():
                            trade_id = row_data['TradeID']
                            checkbox_key = f"expire_{trade_id}"
                            
                            col1, col2, col3, col4, col5, col6, col7, col8 = st.columns([0.3, 1.2, 0.8, 1, 0.8, 1, 1, 1.2])
                            
                            with col1:
                                is_selected = st.checkbox(
                                    "",
                                    key=checkbox_key,
                                    value=st.session_state.expire_checkboxes.get(trade_id, False)
                                )
                                st.session_state.expire_checkboxes[trade_id] = is_selected
                            
                            with col2:
                                st.write(row_data['TradeID'])
                            with col3:
                                st.write(row_data['Type'])
                            with col4:
                                st.write(row_data['Strike'])
                            with col5:
                                st.write(f"{int(row_data['Quantity'])}")
                            with col6:
                                st.write(row_data['Expiry'])
                            with col7:
                                st.write(row_data['DTE'])
                            with col8:
                                st.write(f"{row_data['Premium/Contract']} ‚Üí **{row_data['Total Premium']}**")
                        
                        st.divider()
                    
                    # Collect selected trade IDs and calculate live total premium
                    selected_trade_ids = [
                        trade_id for trade_id in expiring_options['TradeID'].tolist()
                        if st.session_state.expire_checkboxes.get(trade_id, False)
                    ]
                    
                    # Calculate live total premium (updates as checkboxes change)
                    total_premium = 0.0
                    if selected_trade_ids:
                        for trade_id in selected_trade_ids:
                            original = expiring_options[expiring_options['TradeID'] == trade_id].iloc[0]
                            premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                            quantity = pd.to_numeric(original['Quantity'], errors='coerce')
                            if pd.isna(quantity) or quantity <= 0:
                                continue  # Skip invalid quantities in calculation
                            quantity = int(quantity)
                            full_premium = premium * quantity * 100
                            total_premium += full_premium
                    
                    # Display live total premium calculation
                    st.markdown("---")
                    if selected_trade_ids:
                        st.markdown(f"#### Selected: {len(selected_trade_ids)} position(s)")
                        
                        # Show breakdown with premium received details
                        st.markdown("**üí∞ Premium Received Breakdown:**")
                        for trade_id in selected_trade_ids:
                            original = expiring_options[expiring_options['TradeID'] == trade_id].iloc[0]
                            premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                            quantity = pd.to_numeric(original['Quantity'], errors='coerce')
                            if pd.isna(quantity) or quantity <= 0:
                                st.warning(f"‚ö†Ô∏è {trade_id}: Invalid Quantity ({original.get('Quantity', 'N/A')})")
                                continue
                            quantity = int(quantity)
                            full_premium = premium * quantity * 100
                            
                            st.write(f"- **{trade_id}**: {original['TradeType']} {original['Ticker']} | Premium: ${premium:.2f}/contract √ó {quantity} contracts √ó 100 = **${full_premium:,.2f}**")
                        
                        # Live total premium display
                        st.success(f"üí∞ **Total Premium Received: ${total_premium:,.2f}** (Full premium, positions closed at $0.00)")
                        st.info(f"‚úÖ This total premium (${total_premium:,.2f}) will be recorded as **Actual_Profit_(USD)** for each position when expired.")
                        
                        # Expire button
                        if st.button("üöÄ Expire Selected Options", type="primary", key="expire_button"):
                            success_count = 0
                            error_count = 0
                            
                            for trade_id in selected_trade_ids:
                                try:
                                    original = expiring_options[expiring_options['TradeID'] == trade_id].iloc[0]
                                    
                                    handler = ExcelHandler(str(st.session_state.current_data_file))
                                    
                                    # Calculate full premium (actual profit from expiring worthless)
                                    premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                                    quantity = pd.to_numeric(original['Quantity'], errors='coerce')
                                    if pd.isna(quantity) or quantity <= 0:
                                        st.error(f"‚ùå {trade_id}: Invalid Quantity ({original.get('Quantity', 'N/A')})")
                                        error_count += 1
                                        continue
                                    quantity = int(quantity)
                                    full_premium = premium * quantity * 100  # Full premium = actual profit
                                    
                                    # Close option position at $0.00 (expire worthless means full premium collected)
                                    handler.update_trade(trade_id, {
                                        'Status': 'Closed',
                                        'Date_closed': datetime.now(),
                                        'Close_Price': 0.00,  # Expire closes at $0.00
                                        'Actual_Profit_(USD)': full_premium,  # Full premium is the profit
                                        'Remarks': f"{original['TradeType']} Expired Worthless"
                                    })
                                    
                                    # Audit entry (no stock positions created/closed for expire)
                                    handler.append_audit({
                                        'Audit ID': generate_audit_id(st.session_state.df_audit),
                                        'TImeStamp': datetime.now(),
                                        'Action Type': 'Expire',
                                        'TradeID_Ref': trade_id,
                                        'Remarks': f"{original['TradeType']} Expired Worthless",
                                        'ScriptNAme': 'Income Wheel App',
                                        'AffectedQty': quantity
                                    })
                                    
                                    success_count += 1
                                except Exception as e:
                                    st.error(f"‚ùå Error expiring {trade_id}: {e}")
                                    error_count += 1
                            
                            # Show summary and clear if all successful
                            if error_count == 0 and success_count > 0:
                                show_success_and_clear(None, 'expire', f"Successfully expired {success_count} position(s)")
                            elif success_count > 0:
                                st.warning(f"‚ö†Ô∏è {success_count} position(s) expired, {error_count} failed. Please check errors above.")
                                refresh_data()
                            else:
                                st.error(f"‚ùå Failed to expire any positions. Please check errors above.")
                            
                            if success_count > 0:
                                st.success(f"‚úÖ Successfully expired {success_count} position(s)")
                                refresh_data()
                            if error_count > 0:
                                st.warning(f"‚ö†Ô∏è {error_count} position(s) had errors")
    
    # ---- ASSIGNMENT TAB ----
    with tab6:
        st.subheader("Assignment & Exercise")
        display_live_prices_cards()
        
        # Create two sub-tabs for Assignment (CSP) and Exercise (CC)
        sub_tab1, sub_tab2 = st.tabs(["üì• Assignment (CSP)", "üì§ Exercise (CC)"])
        
        # ---- ASSIGNMENT SUB-TAB (CSP) ----
        with sub_tab1:
            st.markdown("#### CSP Assignment")
            
            if df_open is None or df_open.empty:
                st.warning("No open positions")
            else:
                # Filter to CSP only
                open_csps = df_open[df_open['TradeType'] == 'CSP']
                
                if open_csps.empty:
                    st.warning("No open CSP positions")
                else:
                    # Strategy selector before position selector
                    entry_strategy = render_strategy_selector("assignment")
                    position_options = ["‚Äî Select position ‚Äî"] + open_csps.apply(
                        lambda r: f"{r['TradeID']} - CSP {r['Ticker']} ${r['Option_Strike_Price_(USD)']}",
                        axis=1
                    ).tolist()
                    selected = st.selectbox("Select CSP Position", position_options, key=f"assignment_csp_select_{fv}", index=0)
                    if selected and selected != "‚Äî Select position ‚Äî":
                        trade_id = selected.split(' - ')[0]
                        original = open_csps[open_csps['TradeID'] == trade_id].iloc[0]
                        premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                        quantity = int(original['Quantity'])
                        full_premium = premium * quantity * 100
                        col_left, col_right = st.columns(2)
                        with col_left:
                            st.markdown("#### üì• Assignment Details")
                            st.info(f"**You will BUY** {int(quantity * 100)} shares of **{original['Ticker']}** at **${original['Option_Strike_Price_(USD)']:.2f}** per share")
                            st.caption("üí° Assignment for CSPs: You will BUY shares when the put is assigned.")
                        with col_right:
                            st.markdown("#### üí∞ Premium Received")
                            st.metric("Premium per Contract", f"${premium:.2f}")
                            st.metric("Quantity", f"{quantity} contracts")
                            st.metric("**Total Premium Received**", f"**${full_premium:,.2f}**")
                            st.caption(f"Formula: ${premium:.2f} √ó 100 √ó {quantity} = ${full_premium:,.2f}")
                            st.caption(f"‚úÖ This premium will be recorded as **Actual_Profit_(USD)** when assigned.")
                        st.divider()
                        with st.form(f"assignment_csp_form_{fv}"):
                            submitted = st.form_submit_button("Confirm Assignment", type="primary")
                    else:
                        st.caption("Select a position above.")
                        submitted = False
                        trade_id = None
                        original = None
                        
                    if submitted and selected and selected != "‚Äî Select position ‚Äî":
                        valid, msg = TradeValidator.validate_exercise_csp(trade_id, df_open)
                        
                        if not valid:
                            st.error(f"‚ùå {msg}")
                        else:
                            try:
                                handler = ExcelHandler(str(st.session_state.current_data_file))
                                
                                # Calculate full premium (actual profit from assignment)
                                premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                                quantity = int(original['Quantity'])
                                full_premium = premium * quantity * 100
                                
                                # Close option position
                                handler.update_trade(trade_id, {
                                    'Status': 'Closed',
                                    'Date_closed': datetime.now(),
                                    'Close_Price': 0.00,
                                    'Actual_Profit_(USD)': full_premium,
                                    'Remarks': "CSP Assigned - Bought stock"
                                })
                                
                                # Create stock position
                                stock_trade_id = generate_trade_id(df_trades)
                                stock_trade = {
                                    'TradeID': stock_trade_id,
                                    'Ticker': original['Ticker'],
                                    'StrategyType': entry_strategy or 'WHEEL',
                                    'Direction': 'Buy',
                                    'TradeType': 'STOCK',
                                    'Quantity': original['Quantity'] * 100,
                                    'Option_Strike_Price_(USD)': original['Option_Strike_Price_(USD)'],
                                    'Price_of_current_underlying_(USD)': original['Option_Strike_Price_(USD)'],
                                    'Date_open': datetime.now(),
                                    'Status': 'Open',
                                    'Remarks': f"Assigned from {trade_id}"
                                }
                                handler.append_trade(stock_trade)
                                
                                # Audit entry
                                handler.append_audit({
                                    'Audit ID': generate_audit_id(st.session_state.df_audit),
                                    'TImeStamp': datetime.now(),
                                    'Action Type': 'Exercise',
                                    'TradeID_Ref': f"{trade_id}, {stock_trade_id}",
                                    'Remarks': "CSP Assigned - Bought stock",
                                    'ScriptNAme': 'Income Wheel App',
                                    'AffectedQty': original['Quantity']
                                })
                                
                                show_success_and_clear(stock_trade_id, 'assignment', f"Assigned from {trade_id}")
                            except Exception as e:
                                st.error(f"‚ùå Error saving trade: {e}")
                                st.error("‚ö†Ô∏è Trade was NOT saved. Please try again.")
        
        # ---- EXERCISE SUB-TAB (CC) ----
        with sub_tab2:
            st.markdown("#### CC Exercise")
            
            if df_open is None or df_open.empty:
                st.warning("No open positions")
            else:
                # Filter to CC only
                open_ccs = df_open[df_open['TradeType'] == 'CC']
                
                if open_ccs.empty:
                    st.warning("No open CC positions")
                else:
                    entry_strategy = render_strategy_selector("exercise")
                    position_options = ["‚Äî Select position ‚Äî"] + open_ccs.apply(
                        lambda r: f"{r['TradeID']} - CC {r['Ticker']} ${r['Option_Strike_Price_(USD)']}",
                        axis=1
                    ).tolist()
                    selected = st.selectbox("Select CC Position", position_options, key=f"exercise_cc_select_{fv}", index=0)
                    if selected and selected != "‚Äî Select position ‚Äî":
                        trade_id = selected.split(' - ')[0]
                        original = open_ccs[open_ccs['TradeID'] == trade_id].iloc[0]
                        premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                        quantity = int(original['Quantity'])
                        full_premium = premium * quantity * 100
                        col_left, col_right = st.columns(2)
                        with col_left:
                            st.markdown("#### üì§ Exercise Details")
                            st.info(f"**You will SELL/REMOVE** {int(quantity * 100)} shares of **{original['Ticker']}** at **${original['Option_Strike_Price_(USD)']:.2f}** per share")
                            st.caption("üí° Exercise for CCs: You will SELL/REMOVE shares when the call is exercised.")
                        with col_right:
                            st.markdown("#### üí∞ Premium Received")
                            st.metric("Premium per Contract", f"${premium:.2f}")
                            st.metric("Quantity", f"{quantity} contracts")
                            st.metric("**Total Premium Received**", f"**${full_premium:,.2f}**")
                            st.caption(f"Formula: ${premium:.2f} √ó 100 √ó {quantity} = ${full_premium:,.2f}")
                            st.caption(f"‚úÖ This premium will be recorded as **Actual_Profit_(USD)** when exercised.")
                        st.divider()
                        with st.form(f"exercise_cc_form_{fv}"):
                            submitted = st.form_submit_button("Confirm Exercise", type="primary")
                    else:
                        st.caption("Select a position above.")
                        submitted = False
                        trade_id = None
                        original = None
                        
                    if submitted and selected and selected != "‚Äî Select position ‚Äî":
                        valid, msg = TradeValidator.validate_exercise_cc(trade_id, df_open)
                        
                        if not valid:
                            st.error(f"‚ùå {msg}")
                        else:
                            try:
                                handler = ExcelHandler(str(st.session_state.current_data_file))
                                
                                # Calculate full premium (actual profit from exercise)
                                premium = pd.to_numeric(original['OptPremium'], errors='coerce') or 0.0
                                quantity = int(original['Quantity'])
                                full_premium = premium * quantity * 100
                                
                                # Close option position
                                handler.update_trade(trade_id, {
                                    'Status': 'Closed',
                                    'Date_closed': datetime.now(),
                                    'Close_Price': 0.00,
                                    'Actual_Profit_(USD)': full_premium,
                                    'Remarks': "CC Called - Sold stock"
                                })
                                
                                # Close stock position
                                stock_positions = df_open[
                                    (df_open['Ticker'] == original['Ticker']) &
                                    (df_open['TradeType'] == 'STOCK')
                                ]
                                if not stock_positions.empty:
                                    stock_trade_id = stock_positions.iloc[0]['TradeID']
                                    handler.update_trade(stock_trade_id, {
                                        'Status': 'Closed',
                                        'Date_closed': datetime.now(),
                                        'Remarks': f"Called away by {trade_id}"
                                    })
                                    audit_ref = f"{trade_id}, {stock_trade_id}"
                                else:
                                    audit_ref = trade_id
                                
                                # Audit entry
                                handler.append_audit({
                                    'Audit ID': generate_audit_id(st.session_state.df_audit),
                                    'TImeStamp': datetime.now(),
                                    'Action Type': 'Exercise',
                                    'TradeID_Ref': audit_ref,
                                    'Remarks': "CC Called - Sold stock",
                                    'ScriptNAme': 'Income Wheel App',
                                    'AffectedQty': original['Quantity']
                                })
                                
                                stock_id_msg = f"Stock position {stock_trade_id} closed" if not stock_positions.empty else "No stock position found"
                                show_success_and_clear(trade_id, 'exercise', stock_id_msg)
                            except Exception as e:
                                st.error(f"‚ùå Error saving trade: {e}")
                                st.error("‚ö†Ô∏è Trade was NOT saved. Please try again.")
    
    # Display Audit Log (Last 50 Transactions) - this portfolio only (exclude other portfolio's audit refs)
    st.divider()
    if df_audit is not None and not df_audit.empty:
        st.subheader("üìã Recent Trade Activity (Last 50 Transactions)")
        tradeid_col_audit = None
        for col in df_audit.columns:
            if 'tradeid' in col.lower() or 'trade_id' in col.lower():
                tradeid_col_audit = col
                break
        if df_trades is not None and not df_trades.empty and tradeid_col_audit and tradeid_col_audit in df_audit.columns:
            valid_trade_ids = set(df_trades['TradeID'].astype(str).str.strip())
            def _ref_matches(s):
                if not s or s not in valid_trade_ids:
                    base = s.replace('T-', 'T').replace('-', '')
                    for tid in valid_trade_ids:
                        t = str(tid).strip()
                        if t == s or t == base or s == t or (base and t.startswith(s)) or (base and s.startswith(t)):
                            return True
                    return False
                return True
            def ref_in_trades(ref):
                if pd.isna(ref): return False
                s = str(ref).strip()
                # Roll (and similar) rows have "T-001, T-002" ‚Äì keep if any ref is in this portfolio
                for part in s.replace(';', ',').split(','):
                    part = part.strip()
                    if part and _ref_matches(part):
                        return True
                return False
            df_audit = df_audit[df_audit[tradeid_col_audit].apply(ref_in_trades)].copy()
        if df_audit.empty:
            st.info("‚ÑπÔ∏è No trade activity for this portfolio.")
        else:
            timestamp_col = None
            for col in df_audit.columns:
                if 'time' in col.lower() or 'stamp' in col.lower():
                    timestamp_col = col
                    break
            if timestamp_col:
                df_audit_sorted = df_audit.sort_values(timestamp_col, ascending=False).head(50)
            else:
                df_audit_sorted = df_audit.tail(50).iloc[::-1]
            if df_trades is not None and not df_trades.empty:
                tradeid_col = None
                for col in df_audit_sorted.columns:
                    if 'tradeid' in col.lower() or 'trade_id' in col.lower():
                        tradeid_col = col
                        break
                trades_detail_cols = ['TradeID', 'TradeType', 'Direction', 'Ticker', 'Quantity', 'Option_Strike_Price_(USD)']
                trades_detail_cols = [c for c in trades_detail_cols if c in df_trades.columns]
                if tradeid_col and trades_detail_cols:
                    merged = df_audit_sorted.merge(
                        df_trades[trades_detail_cols],
                        left_on=tradeid_col,
                        right_on='TradeID',
                        how='left',
                        suffixes=('', '_trades')
                    )
                    # For Roll etc.: ref may be "T-001, T-002" so merge won't match; fill from first ID in ref
                    lookup_cols = [c for c in ['Ticker', 'Quantity', 'Option_Strike_Price_(USD)'] if c in df_trades.columns]
                    if lookup_cols and tradeid_col in merged.columns:
                        ref_col = tradeid_col
                        has_ticker = 'Ticker' in merged.columns
                        missing = (merged['Ticker'].isna() if has_ticker else merged[ref_col].notna()) & merged[ref_col].notna()
                        if missing.any():
                            tid_lookup = df_trades.set_index('TradeID')[lookup_cols].to_dict('index')
                            for idx in merged.index[missing]:
                                ref_val = merged.at[idx, ref_col]
                                if pd.isna(ref_val) or ref_val == '':
                                    continue
                                first_id = str(ref_val).replace(';', ',').split(',')[0].strip()
                                if first_id and first_id in tid_lookup:
                                    info = tid_lookup[first_id]
                                    for k in lookup_cols:
                                        if k in merged.columns:
                                            merged.at[idx, k] = info.get(k, '')
                elif tradeid_col:
                    merged = df_audit_sorted.merge(
                        df_trades[['TradeID', 'TradeType', 'Direction']],
                        left_on=tradeid_col,
                        right_on='TradeID',
                        how='left'
                    )
                    merged['Ticker'] = ''
                    merged['Quantity'] = ''
                    merged['Option_Strike_Price_(USD)'] = ''
                else:
                    merged = df_audit_sorted.copy()
                    merged['TradeType'] = None
                    merged['Direction'] = None
                    merged['Ticker'] = ''
                    merged['Quantity'] = ''
                    merged['Option_Strike_Price_(USD)'] = ''
            else:
                merged = df_audit_sorted.copy()
                merged['TradeType'] = None
                merged['Direction'] = None
                merged['Ticker'] = ''
                merged['Quantity'] = ''
                merged['Option_Strike_Price_(USD)'] = ''
            
            # Select columns to display (include Ticker, Qty, Strike)
            display_cols = []
            col_mapping = {}
            for col in merged.columns:
                col_lower = col.lower()
                if 'audit id' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Audit ID'
                elif 'tradeid' in col_lower and 'ref' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Trade ID'
                elif col == 'Ticker':
                    display_cols.append(col)
                    col_mapping[col] = 'Ticker'
                elif col == 'Quantity':
                    display_cols.append(col)
                    col_mapping[col] = 'Qty'
                elif col == 'Option_Strike_Price_(USD)':
                    display_cols.append(col)
                    col_mapping[col] = 'Strike ($)'
                elif 'affectedqty' in col_lower or 'affected_qty' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Affected Qty'
                elif 'tradetype' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Trade Type'
                elif 'direction' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Direction'
                elif 'remarks' in col_lower or 'comments' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Comments'
                elif 'action' in col_lower and 'type' in col_lower:
                    display_cols.append(col)
                    col_mapping[col] = 'Action'
                elif timestamp_col and col == timestamp_col:
                    display_cols.append(col)
                    col_mapping[col] = 'Timestamp'
            if display_cols:
                df_display = merged[display_cols].copy()
                df_display = df_display.rename(columns=col_mapping)
                if 'Strike ($)' in df_display.columns:
                    def _fmt_strike(x):
                        if pd.isna(x) or str(x).strip() == '':
                            return ''
                        try:
                            return f"${float(x):.2f}"
                        except (ValueError, TypeError):
                            return str(x)
                    df_display['Strike ($)'] = df_display['Strike ($)'].apply(_fmt_strike)
                if 'Qty' in df_display.columns:
                    def _fmt_qty(x):
                        if pd.isna(x) or str(x).strip() == '':
                            return ''
                        try:
                            return int(float(x))
                        except (ValueError, TypeError):
                            return str(x)
                    df_display['Qty'] = df_display['Qty'].apply(_fmt_qty)
                if 'Timestamp' in df_display.columns:
                    try:
                        df_display['Timestamp'] = pd.to_datetime(df_display['Timestamp'], errors='coerce')
                        df_display['Timestamp'] = df_display['Timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')
                    except Exception:
                        pass
                df_display = df_display.fillna('')
                preferred_order = ['Timestamp', 'Audit ID', 'Trade ID', 'Action', 'Trade Type', 'Ticker', 'Qty', 'Strike ($)', 'Affected Qty', 'Direction', 'Comments']
                existing_cols = [col for col in preferred_order if col in df_display.columns]
                remaining_cols = [col for col in df_display.columns if col not in preferred_order]
                df_display = df_display[existing_cols + remaining_cols]
                column_config = {}
                for c in df_display.columns:
                    if c == 'Comments':
                        column_config[c] = st.column_config.TextColumn(c, width="large")
                    elif c == 'Timestamp':
                        column_config[c] = st.column_config.TextColumn(c, width="medium")
                    else:
                        column_config[c] = st.column_config.TextColumn(c, width="small")
                st.dataframe(df_display, use_container_width=True, hide_index=True, column_config=column_config)
            else:
                st.info("‚ÑπÔ∏è Audit log structure not recognized. Showing raw data:")
                st.dataframe(df_audit_sorted.head(50), use_container_width=True, hide_index=True)
    else:
        st.info("‚ÑπÔ∏è No audit log entries found.")


# ============================================================
# EXPIRY LADDER PAGE
# ============================================================
def render_expiry_ladder():
    """Render expiry ladder visualization"""
    st.title("üìà Expiry Ladder")
    
    df_open = st.session_state.df_open
    df_trades = st.session_state.df_trades
    
    # Filter by strategy if selected
    strategy_filter = st.session_state.get('strategy_filter', 'All')
    if strategy_filter != 'All':
        portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
        pmcc_tickers = get_pmcc_tickers(portfolio)
        pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
        
        if df_open is not None and not df_open.empty:
            if strategy_filter == 'PMCC':
                pmcc_mask = (
                    df_open['Ticker'].isin(pmcc_tickers_set) |
                    (df_open.get('StrategyType', '') == 'PMCC') |
                    (df_open['TradeType'] == 'LEAP')
                )
                df_open = df_open[pmcc_mask].copy()
            elif strategy_filter == 'WHEEL':
                wheel_mask = (
                    ~df_open['Ticker'].isin(pmcc_tickers_set) &
                    (
                        (df_open.get('StrategyType', '') == 'Wheel') |
                        (df_open.get('StrategyType', '').isna()) |
                        (df_open.get('StrategyType', '') == '')
                    ) &
                    (df_open['TradeType'] != 'LEAP')
                )
                df_open = df_open[wheel_mask].copy()
        
        if df_trades is not None and not df_trades.empty:
            if strategy_filter == 'PMCC':
                pmcc_mask = (
                    df_trades['Ticker'].isin(pmcc_tickers_set) |
                    (df_trades.get('StrategyType', '') == 'PMCC') |
                    (df_trades['TradeType'] == 'LEAP')
                )
                df_trades = df_trades[pmcc_mask].copy()
            elif strategy_filter == 'WHEEL':
                wheel_mask = (
                    ~df_trades['Ticker'].isin(pmcc_tickers_set) &
                    (
                        (df_trades.get('StrategyType', '') == 'Wheel') |
                        (df_trades.get('StrategyType', '').isna()) |
                        (df_trades.get('StrategyType', '') == '')
                    ) &
                    (df_trades['TradeType'] != 'LEAP')
                )
                df_trades = df_trades[wheel_mask].copy()
    
    # Get all option positions (open + closed) for 5 years back and forward
    today = date.today()
    start_date = date(today.year - 5, 1, 1)
    end_date = date(today.year + 5, 12, 31)
    
    # Combine open and closed options
    all_options = []
    
    # Add open positions
    if df_open is not None and not df_open.empty:
        open_options = df_open[df_open['TradeType'].isin(['CC', 'CSP'])].copy()
        open_options['Status'] = 'Open'
        all_options.append(open_options)
    
    # Add closed positions
    if df_trades is not None and not df_trades.empty:
        closed_options = df_trades[
            (df_trades['TradeType'].isin(['CC', 'CSP'])) &
            (df_trades['Status'].str.lower() == 'closed')
        ].copy()
        all_options.append(closed_options)
    
    if not all_options:
        st.warning("No option positions found")
        return
    
    # Combine all options
    df_all_options = pd.concat(all_options, ignore_index=True)
    
    # Convert expiry and open date to datetime
    df_all_options['Expiry_Date'] = pd.to_datetime(df_all_options['Expiry_Date'], errors='coerce')
    df_all_options['Date_open'] = pd.to_datetime(df_all_options.get('Date_open'), errors='coerce')
    
    # Filter to 5 years range (by expiry)
    df_all_options = df_all_options[
        (df_all_options['Expiry_Date'].dt.date >= start_date) &
        (df_all_options['Expiry_Date'].dt.date <= end_date)
    ].copy()
    
    if df_all_options.empty:
        st.warning("No option positions in the 5-year range")
        return
    
    # Calculate Friday date for each expiry (options expire on Friday)
    def get_friday_of_week(exp_date):
        if pd.isna(exp_date):
            return pd.NaT
        weekday = exp_date.weekday()  # Monday=0, Sunday=6
        if weekday <= 4:  # Monday to Friday
            return exp_date + timedelta(days=(4 - weekday))
        else:  # Saturday or Sunday - get previous Friday
            return exp_date - timedelta(days=(weekday - 4))
    
    df_all_options['Expiry_Friday'] = df_all_options['Expiry_Date'].apply(get_friday_of_week)
    df_all_options['Friday_Date'] = df_all_options['Expiry_Friday'].dt.strftime('%Y-%m-%d')
    
    # Expiry-based: Year, Month, Week (for ladder and expiry-month filter)
    df_all_options['Year'] = df_all_options['Expiry_Friday'].dt.year
    df_all_options['Month'] = df_all_options['Expiry_Friday'].dt.month
    df_all_options['Week'] = df_all_options['Expiry_Friday'].dt.isocalendar().week
    df_all_options['Month_Name'] = df_all_options['Expiry_Friday'].dt.strftime('%B')
    df_all_options['Year_Month_Str'] = df_all_options['Year'].astype(str) + '-' + df_all_options['Month'].astype(str).str.zfill(2)
    
    # Open-date-based: for "filter by open month"
    df_all_options['Open_Year'] = df_all_options['Date_open'].dt.year
    df_all_options['Open_Month'] = df_all_options['Date_open'].dt.month
    df_all_options['Open_Year_Month_Str'] = df_all_options['Open_Year'].astype(str) + '-' + df_all_options['Open_Month'].astype(str).str.zfill(2)
    
    # Calculate premium
    df_all_options['OptPremium'] = pd.to_numeric(df_all_options['OptPremium'], errors='coerce').fillna(0)
    df_all_options['Quantity'] = pd.to_numeric(df_all_options['Quantity'], errors='coerce').fillna(0)
    df_all_options['Total_Premium'] = df_all_options['OptPremium'] * df_all_options['Quantity'] * 100
    
    # Calculate Actual_Profit_(USD) for closed positions - ALWAYS use Actual_Profit_(USD) for closed CC/CSP
    if 'Actual_Profit_(USD)' in df_all_options.columns:
        df_all_options['Actual_Profit_(USD)'] = pd.to_numeric(df_all_options['Actual_Profit_(USD)'], errors='coerce').fillna(0)
    else:
        df_all_options['Actual_Profit_(USD)'] = 0.0
    
    # For closed positions, ALWAYS use Actual_Profit_(USD) (even if negative or 0) - this includes BTC losses
    # For open positions, use Total_Premium (expected premium)
    df_all_options['Premium_Collected'] = df_all_options.apply(
        lambda row: row['Actual_Profit_(USD)'] if row['Status'] == 'Closed' and row['TradeType'] in ['CC', 'CSP'] else (row['Total_Premium'] if row['Status'] == 'Open' else 0.0),
        axis=1
    )
    
    # ===== FILTERS =====
    st.markdown("### üîç Filters")
    month_filter_basis = st.radio(
        "**Month filter refers to:**",
        ["Expiry month", "Open month"],
        horizontal=True,
        key="ladder_month_basis",
        help="Expiry month = when the option expires; Open month = when the trade was opened."
    )
    use_expiry_for_filter = (month_filter_basis == "Expiry month")
    year_col = 'Year' if use_expiry_for_filter else 'Open_Year'
    month_col = 'Month' if use_expiry_for_filter else 'Open_Month'
    
    filter_col1, filter_col2, filter_col3 = st.columns(3)
    available_years = sorted(df_all_options[year_col].dropna().unique().tolist(), reverse=True)
    available_years = [y for y in available_years if y is not None and not (isinstance(y, float) and pd.isna(y))]
    
    with filter_col1:
        selected_year = st.selectbox("**Filter by Year**", ["All"] + available_years, key="ladder_year_filter")
    
    with filter_col2:
        month_names = {1: "January", 2: "February", 3: "March", 4: "April", 5: "May", 6: "June",
                      7: "July", 8: "August", 9: "September", 10: "October", 11: "November", 12: "December"}
        if selected_year != "All":
            yr = int(selected_year) if isinstance(selected_year, str) and selected_year != "All" else selected_year
            available_months = sorted(df_all_options[df_all_options[year_col] == yr][month_col].dropna().unique().tolist(), reverse=True)
        else:
            available_months = sorted(df_all_options[month_col].dropna().unique().tolist(), reverse=True)
        available_months = [m for m in available_months if m is not None and not (isinstance(m, float) and pd.isna(m))]
        month_options = ["All"] + [f"{month_names.get(int(m), str(m))} ({m})" for m in available_months]
        selected_month_str = st.selectbox("**Filter by Month**", month_options, key="ladder_month_filter")
        selected_month = None if selected_month_str == "All" else int(selected_month_str.split("(")[1].split(")")[0])
    
    with filter_col3:
        available_tickers = sorted(df_all_options['Ticker'].dropna().unique().tolist())
        selected_ticker = st.selectbox("**Filter by Ticker**", ["All"] + available_tickers, key="ladder_ticker_filter")
    
    # Apply filters (year and month use chosen basis: expiry or open)
    df_filtered = df_all_options.copy()
    if selected_year != "All":
        yr = int(selected_year) if isinstance(selected_year, str) else selected_year
        df_filtered = df_filtered[df_filtered[year_col] == yr]
    if selected_month is not None:
        df_filtered = df_filtered[df_filtered[month_col] == selected_month]
    if selected_ticker != "All":
        df_filtered = df_filtered[df_filtered['Ticker'] == selected_ticker]
    
    if df_filtered.empty:
        st.warning("No positions match the selected filters")
        return
    
    # ===== SUMMARY BY MONTH =====
    st.markdown("### üìä Summary by Month")
    st.caption("Totals grouped by month. Use the filter above to restrict by year/ticker; month filter applies to " + ("expiry" if use_expiry_for_filter else "open") + " date.")
    
    # By expiry month
    def agg_expiry(g):
        open_mask = g['Status'] == 'Open'
        closed_mask = g['Status'] == 'Closed'
        return pd.Series({
            'Contracts': g['Quantity'].sum(),
            'Premium_Expected': g.loc[open_mask, 'Total_Premium'].sum(),
            'Premium_Collected': g.loc[closed_mask, 'Premium_Collected'].sum()
        })
    summary_expiry = df_filtered.groupby('Year_Month_Str').apply(agg_expiry).reset_index()
    summary_expiry = summary_expiry.sort_values('Year_Month_Str', ascending=False)
    summary_expiry['Premium_Expected'] = summary_expiry['Premium_Expected'].fillna(0)
    summary_expiry['Premium_Collected'] = summary_expiry['Premium_Collected'].fillna(0)
    summary_expiry['Contracts'] = summary_expiry['Contracts'].astype(int)
    st.markdown("**By expiry month**")
    st.dataframe(
        summary_expiry.style.format({'Premium_Expected': '${:,.2f}', 'Premium_Collected': '${:,.2f}'}, subset=['Premium_Expected', 'Premium_Collected']),
        use_container_width=True,
        hide_index=True
    )
    
    # By open month (only if we have open dates)
    if df_filtered['Date_open'].notna().any():
        def agg_open(g):
            open_mask = g['Status'] == 'Open'
            closed_mask = g['Status'] == 'Closed'
            return pd.Series({
                'Contracts': g['Quantity'].sum(),
                'Premium_Expected': g.loc[open_mask, 'Total_Premium'].sum(),
                'Premium_Collected': g.loc[closed_mask, 'Premium_Collected'].sum()
            })
        summary_open = df_filtered[df_filtered['Open_Year_Month_Str'].notna()].groupby('Open_Year_Month_Str').apply(agg_open).reset_index()
        summary_open = summary_open.rename(columns={'Open_Year_Month_Str': 'Year_Month_Str'})
        summary_open = summary_open.sort_values('Year_Month_Str', ascending=False)
        summary_open['Premium_Expected'] = summary_open['Premium_Expected'].fillna(0)
        summary_open['Premium_Collected'] = summary_open['Premium_Collected'].fillna(0)
        summary_open['Contracts'] = summary_open['Contracts'].astype(int)
        st.markdown("**By open month**")
        st.dataframe(
            summary_open.style.format({'Premium_Expected': '${:,.2f}', 'Premium_Collected': '${:,.2f}'}, subset=['Premium_Expected', 'Premium_Collected']),
            use_container_width=True,
            hide_index=True
        )
    
    st.divider()
    
    # ===== 12-MONTH PREMIUM COLLECTED TREND =====
    st.markdown("### üìä Premium Collected Trend (Last 12 Months)")
    
    # View filter (aggregated vs by ticker)
    view_mode = st.radio(
        "**View Mode:**",
        ["Aggregated", "By Ticker"],
        horizontal=True,
        key="trend_view_mode"
    )
    
    # Get last 12 months of data - only closed CC/CSP trades
    twelve_months_ago = today - timedelta(days=365)
    df_trend = df_all_options[
        (df_all_options['Expiry_Date'].dt.date >= twelve_months_ago) &
        (df_all_options['Status'] == 'Closed') &
        (df_all_options['TradeType'].isin(['CC', 'CSP']))
    ].copy()
    
    # Filter by ticker for trend if selected
    if selected_ticker != "All":
        df_trend = df_trend[df_trend['Ticker'] == selected_ticker]
    
    # Debug: Show what's being counted
    if st.checkbox("üîç Show Debug Info", key="ladder_debug"):
        st.markdown("#### Debug: Trades Included in Trend")
        debug_cols = ['TradeID', 'Ticker', 'TradeType', 'Status', 'Expiry_Date', 'Actual_Profit_(USD)', 'Premium_Collected', 'OptPremium', 'Quantity']
        debug_cols = [c for c in debug_cols if c in df_trend.columns]
        st.dataframe(
            df_trend[debug_cols].sort_values('Expiry_Date', ascending=False),
            use_container_width=True,
            hide_index=True
        )
        st.caption(f"Total trades: {len(df_trend)} | Total Premium Collected: ${df_trend['Premium_Collected'].sum():,.2f}")
    
    if not df_trend.empty:
        # Group by month and ticker (if by ticker view) or just month (if aggregated)
        df_trend['Year_Month'] = df_trend['Expiry_Date'].dt.to_period('M')
        df_trend['Year_Month_Str'] = df_trend['Year_Month'].astype(str)
        
        if view_mode == "By Ticker":
            # Group by month and ticker for stacked chart
            monthly_premium_by_ticker = df_trend.groupby(['Year_Month_Str', 'Ticker']).agg({
                'Premium_Collected': 'sum'
            }).reset_index()
            monthly_premium_by_ticker = monthly_premium_by_ticker.sort_values('Year_Month_Str')
            
            # Pivot for stacked bar chart
            monthly_pivot = monthly_premium_by_ticker.pivot(
                index='Year_Month_Str',
                columns='Ticker',
                values='Premium_Collected'
            ).fillna(0)
            
            # Display stacked column chart
            import plotly.express as px
            fig = px.bar(
                monthly_premium_by_ticker,
                x='Year_Month_Str',
                y='Premium_Collected',
                color='Ticker',
                labels={'Year_Month_Str': 'Month', 'Premium_Collected': 'Premium Collected ($)', 'Ticker': 'Ticker'},
                title=f"Premium Collected by Month (Stacked by Ticker) {'- ' + selected_ticker if selected_ticker != 'All' else '- All Tickers'}",
                barmode='stack'
            )
            fig.update_layout(height=400, xaxis_tickangle=-45)
            st.plotly_chart(fig, use_container_width=True)
            
            # Show summary stats by ticker
            st.markdown("#### üìä Summary by Ticker (Last 12 Months)")
            ticker_totals = df_trend.groupby('Ticker').agg({
                'Premium_Collected': 'sum'
            }).reset_index()
            ticker_totals = ticker_totals.sort_values('Premium_Collected', ascending=False)
            ticker_totals['Premium_Collected'] = ticker_totals['Premium_Collected'].apply(lambda x: f"${x:,.2f}")
            ticker_totals.columns = ['Ticker', 'Total Premium (12M)']
            st.dataframe(ticker_totals, use_container_width=True, hide_index=True)
            
        else:
            # Aggregated view - group by month only
            monthly_premium = df_trend.groupby('Year_Month_Str').agg({
                'Premium_Collected': 'sum'
            }).reset_index()
            monthly_premium = monthly_premium.sort_values('Year_Month_Str')
            
            # Display simple bar chart
            import plotly.express as px
            fig = px.bar(
                monthly_premium,
                x='Year_Month_Str',
                y='Premium_Collected',
                labels={'Year_Month_Str': 'Month', 'Premium_Collected': 'Premium Collected ($)'},
                title=f"Premium Collected by Month (Aggregated) {'- ' + selected_ticker if selected_ticker != 'All' else '- All Tickers'}"
            )
            fig.update_layout(height=400, xaxis_tickangle=-45)
            st.plotly_chart(fig, use_container_width=True)
        
        # Show summary stats (same for both views)
        total_12m = df_trend['Premium_Collected'].sum()
        avg_monthly = df_trend.groupby('Year_Month_Str')['Premium_Collected'].sum().mean()
        best_month = df_trend.groupby('Year_Month_Str')['Premium_Collected'].sum().max()
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total Premium (12M)", f"${total_12m:,.2f}")
        with col2:
            st.metric("Average Monthly", f"${avg_monthly:,.2f}")
        with col3:
            st.metric("Best Month", f"${best_month:,.2f}")
        
        # Show comparison with Dashboard calculation
        st.markdown("#### üìä Comparison with Dashboard")
        st.caption("Note: Dashboard MTD/YTD filters by expiry date in the period. This trend shows all closed trades in last 12 months.")
        
        # Calculate total all-time premium collected (for comparison)
        all_closed = df_all_options[
            (df_all_options['Status'] == 'Closed') &
            (df_all_options['TradeType'].isin(['CC', 'CSP']))
        ].copy()
        total_all_time = all_closed['Premium_Collected'].sum()
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Total All-Time Premium Collected", f"${total_all_time:,.2f}")
        with col2:
            st.metric("Last 12 Months Premium", f"${total_12m:,.2f}")
    else:
        st.info("No premium collected data for the last 12 months")
    
    st.divider()
    
    # ===== PREMIUM EXPECTED (Next 2 Months) =====
    st.markdown("### üí∞ Premium Expected (Next 2 Months)")
    
    # Get open positions expiring in next 2 months
    two_months_later = today + timedelta(days=60)
    df_expected = df_all_options[
        (df_all_options['Expiry_Date'].dt.date >= today) &
        (df_all_options['Expiry_Date'].dt.date <= two_months_later) &
        (df_all_options['Status'] == 'Open') &
        (df_all_options['TradeType'].isin(['CC', 'CSP']))
    ].copy()
    
    if not df_expected.empty:
        # Group by Friday date (week) and calculate total premium expected
        df_expected['Expiry_Friday'] = df_expected['Expiry_Date'].apply(get_friday_of_week)
        df_expected['Friday_Date'] = df_expected['Expiry_Friday'].dt.strftime('%Y-%m-%d')
        
        # Calculate premium expected per week
        weekly_expected = df_expected.groupby('Friday_Date').agg({
            'Total_Premium': 'sum'
        }).reset_index()
        weekly_expected.columns = ['Week', 'Premium Expected']
        weekly_expected = weekly_expected.sort_values('Week')
        
        # Also group by ticker for stacked view option
        weekly_expected_by_ticker = df_expected.groupby(['Friday_Date', 'Ticker']).agg({
            'Total_Premium': 'sum'
        }).reset_index()
        weekly_expected_by_ticker.columns = ['Week', 'Ticker', 'Premium Expected']
        weekly_expected_by_ticker = weekly_expected_by_ticker.sort_values('Week')
        
        # View mode for expected premium
        expected_view_mode = st.radio(
            "**View Mode:**",
            ["Aggregated", "By Ticker"],
            horizontal=True,
            key="expected_premium_view_mode"
        )
        
        import plotly.express as px
        
        if expected_view_mode == "By Ticker":
            # Stacked column chart by ticker
            fig_expected = px.bar(
                weekly_expected_by_ticker,
                x='Week',
                y='Premium Expected',
                color='Ticker',
                labels={'Week': 'Expiry Week (Friday)', 'Premium Expected': 'Premium Expected ($)', 'Ticker': 'Ticker'},
                title="Premium Expected by Week (Next 2 Months) - By Ticker",
                barmode='stack'
            )
            fig_expected.update_layout(height=400, xaxis_tickangle=-45)
            st.plotly_chart(fig_expected, use_container_width=True)
            
            # Summary by ticker
            ticker_expected_summary = df_expected.groupby('Ticker').agg({
                'Total_Premium': 'sum'
            }).reset_index()
            ticker_expected_summary.columns = ['Ticker', 'Total Expected (2M)']
            ticker_expected_summary = ticker_expected_summary.sort_values('Total Expected (2M)', ascending=False)
            ticker_expected_summary['Total Expected (2M)'] = ticker_expected_summary['Total Expected (2M)'].apply(lambda x: f"${x:,.2f}")
            st.markdown("#### üìä Summary by Ticker (Next 2 Months)")
            st.dataframe(ticker_expected_summary, use_container_width=True, hide_index=True)
        else:
            # Aggregated view
            fig_expected = px.bar(
                weekly_expected,
                x='Week',
                y='Premium Expected',
                labels={'Week': 'Expiry Week (Friday)', 'Premium Expected': 'Premium Expected ($)'},
                title="Premium Expected by Week (Next 2 Months) - Aggregated"
            )
            fig_expected.update_layout(height=400, xaxis_tickangle=-45)
            st.plotly_chart(fig_expected, use_container_width=True)
        
        # Summary metrics
        total_expected_2m = df_expected['Total_Premium'].sum()
        avg_weekly_expected = weekly_expected['Premium Expected'].mean()
        max_weekly_expected = weekly_expected['Premium Expected'].max()
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total Expected (2M)", f"${total_expected_2m:,.2f}")
        with col2:
            st.metric("Average Weekly", f"${avg_weekly_expected:,.2f}")
        with col3:
            st.metric("Peak Week", f"${max_weekly_expected:,.2f}")
    else:
        st.info("No open positions expiring in the next 2 months")
    
    st.divider()
    
    # ===== EXPIRY LADDER BY WEEK =====
    st.markdown("### üìÖ Expiry Ladder by Week")
    st.caption("Grouped by expiry week (Friday). Use filters at the top to restrict by year, month (expiry or open), and ticker.")
    
    if df_filtered.empty:
        st.warning("No positions match the selected filters")
        return
    
    # Sort by Year, Month, Week, Ticker, TradeType (descending - latest date first)
    df_filtered = df_filtered.sort_values(['Year', 'Month', 'Week', 'Ticker', 'TradeType'], ascending=[False, False, False, True, True])
    
    # Group by Friday date (week) - sort groups by date descending (latest first)
    friday_groups = df_filtered.groupby('Friday_Date')
    
    # Sort Friday dates in descending order (latest date first)
    sorted_friday_dates = sorted(friday_groups.groups.keys(), reverse=True)
    
    # Display each week group with details (latest date first)
    for friday_date in sorted_friday_dates:
        week_data = friday_groups.get_group(friday_date)
        # Sort within week by Ticker, TradeType
        week_data_sorted = week_data.sort_values(['Ticker', 'TradeType'])
        
        # Calculate summary for this week
        total_contracts = int(week_data_sorted['Quantity'].sum())
        total_premium_expected = week_data_sorted[week_data_sorted['Status'] == 'Open']['Total_Premium'].sum()
        total_premium_collected = week_data_sorted[week_data_sorted['Status'] == 'Closed']['Premium_Collected'].sum()
        
        # Calculate summary by ticker
        ticker_summary_data = []
        for ticker in week_data_sorted['Ticker'].unique():
            ticker_data = week_data_sorted[week_data_sorted['Ticker'] == ticker]
            contracts = int(ticker_data['Quantity'].sum())
            expected = ticker_data[ticker_data['Status'] == 'Open']['Total_Premium'].sum()
            collected = ticker_data[ticker_data['Status'] == 'Closed']['Premium_Collected'].sum()
            ticker_summary_data.append({
                'Ticker': ticker,
                'Contracts': contracts,
                'Expected': expected,
                'Collected': collected
            })
        ticker_summary = pd.DataFrame(ticker_summary_data)
        
        # Display week header with summary
        with st.expander(f"üìÖ **{friday_date}** - {total_contracts} contracts | Expected: ${total_premium_expected:,.2f} | Collected: ${total_premium_collected:,.2f}"):
            # Show summary by ticker
            if not ticker_summary.empty:
                st.markdown("#### Summary by Ticker")
                ticker_display = ticker_summary.copy()
                ticker_display['Contracts'] = ticker_display['Contracts'].apply(lambda x: f"{int(x)}")
                ticker_display['Expected'] = ticker_display['Expected'].apply(lambda x: f"${x:,.2f}")
                ticker_display['Collected'] = ticker_display['Collected'].apply(lambda x: f"${x:,.2f}")
                st.dataframe(
                    ticker_display,
                    use_container_width=True,
                    hide_index=True,
                    column_config={
                        "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                        "Contracts": st.column_config.TextColumn("Contracts", width="small"),
                        "Expected": st.column_config.TextColumn("Expected", width="medium"),
                        "Collected": st.column_config.TextColumn("Collected", width="medium")
                    }
                )
                st.divider()
            
            # Prepare display data
            display_data = []
            for _, row in week_data_sorted.iterrows():
                display_data.append({
                    'TradeID': row.get('TradeID', 'N/A'),
                    'Ticker': row.get('Ticker', 'N/A'),
                    'Type': row.get('TradeType', 'N/A'),
                    'Status': row.get('Status', 'N/A'),
                    'Strike': f"${row.get('Option_Strike_Price_(USD)', 0):.2f}",
                    'Quantity': int(row.get('Quantity', 0)),
                    'Premium': f"${row.get('OptPremium', 0):.2f}",
                    'Total Premium': f"${row.get('Total_Premium', 0):,.2f}",
                    'Premium Collected': f"${row.get('Premium_Collected', 0):,.2f}" if row.get('Status') == 'Closed' else "N/A",
                    'Expiry Date': row['Expiry_Date'].strftime('%Y-%m-%d') if pd.notna(row['Expiry_Date']) else 'N/A'
                })
            
            df_display = pd.DataFrame(display_data)
            
            st.markdown("#### Detailed Positions")
            st.dataframe(
                df_display,
                use_container_width=True,
                hide_index=True,
                column_config={
                    "TradeID": st.column_config.TextColumn("TradeID", width="small"),
                    "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                    "Type": st.column_config.TextColumn("Type", width="small"),
                    "Status": st.column_config.TextColumn("Status", width="small"),
                    "Strike": st.column_config.TextColumn("Strike", width="small"),
                    "Quantity": st.column_config.NumberColumn("Quantity", width="small"),
                    "Premium": st.column_config.TextColumn("Premium", width="small"),
                    "Total Premium": st.column_config.TextColumn("Total Premium", width="medium"),
                    "Premium Collected": st.column_config.TextColumn("Premium Collected", width="medium"),
                    "Expiry Date": st.column_config.TextColumn("Expiry Date", width="small")
                }
            )


# ============================================================
# ANALYTICS PAGE
# ============================================================
def render_performance():
    """Render performance page with P&L breakdown by ticker"""
    st.title("üìä Performance")
    
    df_trades = st.session_state.df_trades
    df_open = st.session_state.df_open
    
    if df_trades is None or df_trades.empty:
        st.warning("No trades found")
        return
    
    # Filter by strategy if selected
    strategy_filter = st.session_state.get('strategy_filter', 'All')
    if strategy_filter != 'All':
        portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
        pmcc_tickers = get_pmcc_tickers(portfolio)
        pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
        
        if strategy_filter == 'PMCC':
            pmcc_mask = (
                df_trades['Ticker'].isin(pmcc_tickers_set) |
                (df_trades.get('StrategyType', '') == 'PMCC') |
                (df_trades['TradeType'] == 'LEAP')
            )
            df_trades = df_trades[pmcc_mask].copy()
            if df_open is not None and not df_open.empty:
                pmcc_mask_open = (
                    df_open['Ticker'].isin(pmcc_tickers_set) |
                    (df_open.get('StrategyType', '') == 'PMCC') |
                    (df_open['TradeType'] == 'LEAP')
                )
                df_open = df_open[pmcc_mask_open].copy()
        elif strategy_filter == 'WHEEL':
            wheel_mask = (
                ~df_trades['Ticker'].isin(pmcc_tickers_set) &
                (
                    (df_trades.get('StrategyType', '') == 'Wheel') |
                    (df_trades.get('StrategyType', '').isna()) |
                    (df_trades.get('StrategyType', '') == '')
                ) &
                (df_trades['TradeType'] != 'LEAP')
            )
            df_trades = df_trades[wheel_mask].copy()
            if df_open is not None and not df_open.empty:
                wheel_mask_open = (
                    ~df_open['Ticker'].isin(pmcc_tickers_set) &
                    (
                        (df_open.get('StrategyType', '') == 'Wheel') |
                        (df_open.get('StrategyType', '').isna()) |
                        (df_open.get('StrategyType', '') == '')
                    ) &
                    (df_open['TradeType'] != 'LEAP')
                )
                df_open = df_open[wheel_mask_open].copy()
        
        if df_trades.empty:
            st.info(f"‚ÑπÔ∏è No trades found for {strategy_filter} strategy.")
            return
    
    # Get live prices
    from price_feed import get_cached_prices
    all_tickers = df_trades['Ticker'].unique().tolist()
    if df_open is not None and not df_open.empty:
        all_tickers.extend(df_open['Ticker'].unique().tolist())
    all_tickers = sorted(list(set(all_tickers)))
    live_prices = get_cached_prices(all_tickers)
    
    # Load persisted values
    from persistence import get_stock_average_prices, save_stock_average_prices, get_spy_leap_pl, save_spy_leap_pl
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    stock_avg_prices = get_stock_average_prices(portfolio)
    spy_leap_pl = get_spy_leap_pl(portfolio)
    
    # ===== PREMIUM COLLECTED BY TICKER =====
    st.subheader("üí∞ Premium Collected by Ticker")
    
    # Get all closed option trades (CC and CSP) - MUST be closed and MUST be CC or CSP
    df_closed_options = df_trades[
        (df_trades['Status'].str.lower() == 'closed') &
        (df_trades['TradeType'].isin(['CC', 'CSP']))
    ].copy()
    
    # ALWAYS use Actual_Profit_(USD) for closed CC/CSP trades
    if 'Actual_Profit_(USD)' in df_closed_options.columns:
        df_closed_options['Actual_Profit_(USD)'] = pd.to_numeric(df_closed_options['Actual_Profit_(USD)'], errors='coerce').fillna(0)
        # Use Actual_Profit_(USD) directly (even if 0, as it represents the actual P&L)
        df_closed_options['Premium_Collected'] = df_closed_options['Actual_Profit_(USD)']
    else:
        # Fallback: if column doesn't exist, calculate from OptPremium (shouldn't happen in normal operation)
        df_closed_options['OptPremium'] = pd.to_numeric(df_closed_options['OptPremium'], errors='coerce').fillna(0)
        df_closed_options['Quantity'] = pd.to_numeric(df_closed_options['Quantity'], errors='coerce').fillna(0)
        df_closed_options['Premium_Collected'] = df_closed_options['OptPremium'] * 100 * df_closed_options['Quantity']
        st.warning("‚ö†Ô∏è Actual_Profit_(USD) column not found. Using OptPremium calculation as fallback.")
    
    # Group by ticker
    premium_by_ticker = df_closed_options.groupby('Ticker').agg({
        'Premium_Collected': 'sum'
    }).reset_index()
    premium_by_ticker.columns = ['Ticker', 'Premium_Collected']
    
    # ===== STOCK POSITIONS =====
    st.subheader("üìà Stock Positions (Live Prices)")
    
    # Get stock positions (STOCK and LEAP)
    stock_positions = []
    if df_open is not None and not df_open.empty:
        stock_df = df_open[df_open['TradeType'].isin(['STOCK', 'LEAP'])].copy()
        for _, row in stock_df.iterrows():
            ticker = row['Ticker']
            trade_type = row['TradeType']
            quantity = pd.to_numeric(row.get('Open_lots', row.get('Quantity', 0)), errors='coerce') or 0
            if trade_type == 'LEAP':
                quantity = abs(quantity)  # LEAPs are long positions
            
            stock_positions.append({
                'Ticker': ticker,
                'Type': trade_type,
                'Quantity': quantity,
                'Live_Price': live_prices.get(ticker, 0.0)
            })
    
    # Create performance dataframe
    all_tickers_perf = sorted(list(set(premium_by_ticker['Ticker'].tolist() + [p['Ticker'] for p in stock_positions])))
    
    performance_data = []
    for ticker in all_tickers_perf:
        # Premium collected
        premium = premium_by_ticker[premium_by_ticker['Ticker'] == ticker]['Premium_Collected'].sum()
        
        # Stock position info
        ticker_stocks = [p for p in stock_positions if p['Ticker'] == ticker]
        total_shares = sum(p['Quantity'] for p in ticker_stocks)
        live_price = ticker_stocks[0]['Live_Price'] if ticker_stocks else live_prices.get(ticker, 0.0)
        
        # Get average price (from persistence or calculate)
        avg_price = stock_avg_prices.get(ticker, 0.0)
        
        # Calculate stock P&L
        # Special handling for SPY LEAP P&L
        if ticker == 'SPY':
            # Check if there are LEAPs
            spy_leaps = [p for p in ticker_stocks if p['Type'] == 'LEAP']
            spy_regular = [p for p in ticker_stocks if p['Type'] == 'STOCK']
            
            if spy_leaps and spy_leap_pl != 0:
                # Use manual LEAP P&L if entered
                leap_pl = spy_leap_pl
            elif spy_leaps and avg_price > 0:
                # Calculate LEAP P&L from average price if available
                spy_leap_shares = sum(p['Quantity'] for p in spy_leaps)
                leap_pl = (live_price - avg_price) * spy_leap_shares
            else:
                leap_pl = 0.0
            
            # Calculate regular stock P&L
            if spy_regular and avg_price > 0:
                spy_regular_shares = sum(p['Quantity'] for p in spy_regular)
                regular_pl = (live_price - avg_price) * spy_regular_shares
            else:
                regular_pl = 0.0
            
            stock_pl = leap_pl + regular_pl
        elif avg_price > 0 and total_shares > 0:
            stock_pl = (live_price - avg_price) * total_shares
        else:
            stock_pl = 0.0
        
        # Total P&L
        total_pl = premium + stock_pl
        
        performance_data.append({
            'Ticker': ticker,
            'Premium_Collected': premium,
            'Stock_Shares': total_shares,
            'Avg_Price': avg_price,
            'Live_Price': live_price,
            'Stock_PL': stock_pl,
            'Total_PL': total_pl
        })
    
    df_performance = pd.DataFrame(performance_data)
    
    # ===== USER INPUTS FOR STOCK AVERAGE PRICES =====
    st.markdown("#### ‚öôÔ∏è Stock Average Prices (Manual Entry)")
    st.caption("Enter average cost basis for each ticker (from broker). Values are persisted.")
    
    # Create editable table for average prices
    avg_price_data = []
    for ticker in sorted(all_tickers_perf):
        current_avg = stock_avg_prices.get(ticker, 0.0)
        avg_price_data.append({
            'Ticker': ticker,
            'Average_Price': current_avg
        })
    
    df_avg_prices = pd.DataFrame(avg_price_data)
    
    edited_avg_prices = st.data_editor(
        df_avg_prices,
        use_container_width=True,
        hide_index=True,
        column_config={
            "Ticker": st.column_config.TextColumn("Ticker", width="small", disabled=True),
            "Average_Price": st.column_config.NumberColumn("Average Price ($)", width="medium", min_value=0.0, step=0.01)
        },
        key="avg_prices_editor"
    )
    
    # Save average prices on change
    if not edited_avg_prices.equals(df_avg_prices):
        new_avg_prices = {}
        for _, row in edited_avg_prices.iterrows():
            if row['Average_Price'] > 0:
                new_avg_prices[row['Ticker']] = float(row['Average_Price'])
        save_stock_average_prices(new_avg_prices, portfolio)
        stock_avg_prices = new_avg_prices
        st.toast("Average prices saved. Form cleared.", icon="‚úÖ")
        st.success("‚úÖ Average prices saved!")
        st.rerun()
    
    # ===== SPY LEAP P&L MANUAL ENTRY =====
    st.markdown("#### üéØ SPY LEAP P&L (Manual Entry)")
    st.caption("Enter SPY LEAP P&L manually (non-linear calculations from broker). Value is persisted.")
    
    col1, col2 = st.columns([2, 1])
    with col1:
        new_spy_leap_pl = st.number_input(
            "SPY LEAP P&L ($)",
            value=spy_leap_pl,
            step=0.01,
            format="%.2f",
            key="spy_leap_pl_input"
        )
    with col2:
        if st.button("üíæ Save SPY LEAP P&L", key="save_spy_leap"):
            save_spy_leap_pl(new_spy_leap_pl, portfolio)
            st.toast("SPY LEAP P&L saved.", icon="‚úÖ")
            st.success("‚úÖ SPY LEAP P&L saved!")
            st.rerun()
    
    st.divider()
    
    # ===== PERFORMANCE TABLE =====
    st.markdown("#### üìä Performance Breakdown by Ticker")
    
    # Recalculate with updated values
    for idx, row in df_performance.iterrows():
        ticker = row['Ticker']
        avg_price = stock_avg_prices.get(ticker, 0.0)
        ticker_stocks = [p for p in stock_positions if p['Ticker'] == ticker]
        live_price = row['Live_Price']
        
        # Calculate stock P&L
        if ticker == 'SPY':
            # Check if there are LEAPs
            spy_leaps = [p for p in ticker_stocks if p['Type'] == 'LEAP']
            spy_regular = [p for p in ticker_stocks if p['Type'] == 'STOCK']
            
            if spy_leaps and spy_leap_pl != 0:
                # Use manual LEAP P&L if entered
                leap_pl = spy_leap_pl
            elif spy_leaps and avg_price > 0:
                # Calculate LEAP P&L from average price if available
                spy_leap_shares = sum(p['Quantity'] for p in spy_leaps)
                leap_pl = (live_price - avg_price) * spy_leap_shares
            else:
                leap_pl = 0.0
            
            # Calculate regular stock P&L
            if spy_regular and avg_price > 0:
                spy_regular_shares = sum(p['Quantity'] for p in spy_regular)
                regular_pl = (live_price - avg_price) * spy_regular_shares
            else:
                regular_pl = 0.0
            
            stock_pl = leap_pl + regular_pl
        elif avg_price > 0:
            total_shares = sum(p['Quantity'] for p in ticker_stocks)
            if total_shares > 0:
                stock_pl = (live_price - avg_price) * total_shares
            else:
                stock_pl = 0.0
        else:
            stock_pl = 0.0
        
        df_performance.at[idx, 'Avg_Price'] = avg_price
        df_performance.at[idx, 'Stock_PL'] = stock_pl
        df_performance.at[idx, 'Total_PL'] = row['Premium_Collected'] + stock_pl
    
    # Format for display (guard: empty or missing columns e.g. Active Core without options data)
    df_display = df_performance.copy()
    if df_display.empty or 'Premium_Collected' not in df_display.columns:
        df_display = pd.DataFrame(columns=['Ticker', 'Premium Collected', 'Stock Shares', 'Avg Price', 'Live Price', 'Stock P&L', 'Total P&L'])
        st.dataframe(df_display, use_container_width=True, hide_index=True)
        total_premium = total_stock_pl = total_pl = 0.0
    else:
        df_display['Premium_Collected'] = df_display['Premium_Collected'].apply(lambda x: f"${x:,.2f}")
        df_display['Stock_Shares'] = df_display['Stock_Shares'].apply(lambda x: f"{int(x):,}" if x > 0 else "0")
        df_display['Avg_Price'] = df_display['Avg_Price'].apply(lambda x: f"${x:.2f}" if x > 0 else "N/A")
        df_display['Live_Price'] = df_display['Live_Price'].apply(lambda x: f"${x:.2f}" if x > 0 else "N/A")
        df_display['Stock_PL'] = df_display['Stock_PL'].apply(lambda x: f"${x:,.2f}")
        df_display['Total_PL'] = df_display['Total_PL'].apply(lambda x: f"${x:,.2f}")
        df_display.columns = ['Ticker', 'Premium Collected', 'Stock Shares', 'Avg Price', 'Live Price', 'Stock P&L', 'Total P&L']
        st.dataframe(
            df_display,
            use_container_width=True,
            hide_index=True,
            column_config={
                "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                "Premium Collected": st.column_config.TextColumn("Premium Collected", width="medium"),
                "Stock Shares": st.column_config.TextColumn("Stock Shares", width="small"),
                "Avg Price": st.column_config.TextColumn("Avg Price", width="small"),
                "Live Price": st.column_config.TextColumn("Live Price", width="small"),
                "Stock P&L": st.column_config.TextColumn("Stock P&L", width="medium"),
                "Total P&L": st.column_config.TextColumn("Total P&L", width="medium")
            }
        )
        total_premium = df_performance['Premium_Collected'].sum()
        total_stock_pl = df_performance['Stock_PL'].sum()
        total_pl = df_performance['Total_PL'].sum()
    
    # ===== PORTFOLIO TOTAL =====
    st.divider()
    st.markdown("#### üéØ Portfolio Total P&L")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Premium Collected", f"${total_premium:,.2f}")
    with col2:
        st.metric("Total Stock P&L", f"${total_stock_pl:,.2f}")
    with col3:
        st.metric("**Total Portfolio P&L**", f"**${total_pl:,.2f}**", 
                 delta=f"${total_pl:,.2f}" if total_pl != 0 else None)


# ============================================================
# ALL POSITIONS PAGE
# ============================================================
def render_all_positions():
    """Render all positions table"""
    st.title("üìã All Positions")
    
    df_trades = st.session_state.df_trades
    
    if df_trades is None or df_trades.empty:
        st.warning("No trades found")
        return
    
    # Filter by strategy if selected
    strategy_filter = st.session_state.get('strategy_filter', 'All')
    if strategy_filter != 'All':
        portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
        pmcc_tickers = get_pmcc_tickers(portfolio)
        pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
        
        if strategy_filter == 'PMCC':
            pmcc_mask = (
                df_trades['Ticker'].isin(pmcc_tickers_set) |
                (df_trades.get('StrategyType', '') == 'PMCC') |
                (df_trades['TradeType'] == 'LEAP')
            )
            df_trades = df_trades[pmcc_mask].copy()
        elif strategy_filter == 'WHEEL':
            wheel_mask = (
                ~df_trades['Ticker'].isin(pmcc_tickers_set) &
                (
                    (df_trades.get('StrategyType', '') == 'Wheel') |
                    (df_trades.get('StrategyType', '').isna()) |
                    (df_trades.get('StrategyType', '') == '')
                ) &
                (df_trades['TradeType'] != 'LEAP')
            )
            df_trades = df_trades[wheel_mask].copy()
        
        if df_trades.empty:
            st.info(f"‚ÑπÔ∏è No trades found for {strategy_filter} strategy.")
            return
    
    # Convert Expiry_Date to datetime for filtering
    df_trades = df_trades.copy()
    if 'Expiry_Date' in df_trades.columns:
        df_trades['Expiry_Date'] = pd.to_datetime(df_trades['Expiry_Date'], errors='coerce')
        df_trades['Expiry_Year'] = df_trades['Expiry_Date'].dt.year
        df_trades['Expiry_Month'] = df_trades['Expiry_Date'].dt.month
    
    # ===== FILTERS =====
    st.markdown("### üîç Filters")
    filter_col1, filter_col2, filter_col3, filter_col4, filter_col5 = st.columns(5)
    
    with filter_col1:
        status_filter = st.selectbox("**Status**", ["All", "Open", "Closed"], key="all_pos_status")
    
    with filter_col2:
        type_filter = st.selectbox("**Type**", ["All", "CC", "CSP", "STOCK", "LEAP"], key="all_pos_type")
    
    with filter_col3:
        ticker_filter = st.selectbox("**Ticker**", ["All"] + sorted(df_trades['Ticker'].unique().tolist()), key="all_pos_ticker")
    
    with filter_col4:
        # Expiry Year filter
        if 'Expiry_Year' in df_trades.columns:
            available_years = sorted([y for y in df_trades['Expiry_Year'].dropna().unique().tolist() if pd.notna(y)], reverse=True)
            expiry_year_filter = st.selectbox("**Expiry Year**", ["All"] + [str(int(y)) for y in available_years], key="all_pos_year")
        else:
            expiry_year_filter = "All"
    
    with filter_col5:
        # Expiry Month filter
        if 'Expiry_Month' in df_trades.columns and expiry_year_filter != "All":
            year_int = int(expiry_year_filter)
            available_months = sorted([m for m in df_trades[df_trades['Expiry_Year'] == year_int]['Expiry_Month'].dropna().unique().tolist() if pd.notna(m)], reverse=True)
            month_names = {1: "January", 2: "February", 3: "March", 4: "April", 5: "May", 6: "June",
                          7: "July", 8: "August", 9: "September", 10: "October", 11: "November", 12: "December"}
            month_options = ["All"] + [f"{month_names[int(m)]} ({int(m)})" for m in available_months]
            expiry_month_filter_str = st.selectbox("**Expiry Month**", month_options, key="all_pos_month")
            expiry_month_filter = None if expiry_month_filter_str == "All" else int(expiry_month_filter_str.split("(")[1].split(")")[0])
        elif 'Expiry_Month' in df_trades.columns:
            available_months = sorted([m for m in df_trades['Expiry_Month'].dropna().unique().tolist() if pd.notna(m)], reverse=True)
            month_names = {1: "January", 2: "February", 3: "March", 4: "April", 5: "May", 6: "June",
                          7: "July", 8: "August", 9: "September", 10: "October", 11: "November", 12: "December"}
            month_options = ["All"] + [f"{month_names[int(m)]} ({int(m)})" for m in available_months]
            expiry_month_filter_str = st.selectbox("**Expiry Month**", month_options, key="all_pos_month")
            expiry_month_filter = None if expiry_month_filter_str == "All" else int(expiry_month_filter_str.split("(")[1].split(")")[0])
        else:
            expiry_month_filter = None
    
    # Apply filters
    df_filtered = df_trades.copy()
    
    if status_filter != "All":
        df_filtered = df_filtered[df_filtered['Status'].str.lower() == status_filter.lower()]
    if type_filter != "All":
        df_filtered = df_filtered[df_filtered['TradeType'] == type_filter]
    if ticker_filter != "All":
        df_filtered = df_filtered[df_filtered['Ticker'] == ticker_filter]
    if expiry_year_filter != "All" and 'Expiry_Year' in df_filtered.columns:
        df_filtered = df_filtered[df_filtered['Expiry_Year'] == int(expiry_year_filter)]
    if expiry_month_filter is not None and 'Expiry_Month' in df_filtered.columns:
        df_filtered = df_filtered[df_filtered['Expiry_Month'] == expiry_month_filter]
    
    st.write(f"Showing {len(df_filtered)} of {len(df_trades)} trades")
    st.divider()
    
    # ===== COLUMN SELECTION =====
    st.markdown("### üìä Column Selection")
    st.caption("Select which columns to display from the data schema")
    
    # Get all available columns from the dataframe (exclude helper columns)
    all_columns = [col for col in df_filtered.columns if col not in ['Expiry_Year', 'Expiry_Month']]
    
    # Default columns (always include TradeID)
    default_cols = ['TradeID', 'Ticker', 'TradeType', 'Status', 'Quantity', 'Date_open', 'Expiry_Date']
    default_cols = [col for col in default_cols if col in all_columns]
    
    # Column selection with multiselect
    selected_columns = st.multiselect(
        "Select columns to display:",
        options=all_columns,
        default=default_cols,
        key="all_pos_columns"
    )
    
    # Ensure TradeID is always included if available
    if 'TradeID' in all_columns and 'TradeID' not in selected_columns:
        selected_columns.insert(0, 'TradeID')
    
    if not selected_columns:
        st.warning("Please select at least one column to display")
        return
    
    # Filter to only selected columns that exist in dataframe
    display_cols = [col for col in selected_columns if col in df_filtered.columns]
    
    if not display_cols:
        st.warning("No valid columns selected")
        return
    
    # Display table (with Delete checkbox column)
    st.markdown("### üìã Positions Table")
    st.caption("Check **Delete** for rows to remove from the Data Table, then confirm and click Delete selected.")
    
    # Ensure TradeID is in display for delete to work
    if 'TradeID' not in display_cols:
        display_cols = ['TradeID'] + [c for c in display_cols if c != 'TradeID']
    
    # Sort dataframe
    if 'Date_open' in display_cols:
        sort_col = 'Date_open'
    elif 'TradeID' in display_cols:
        sort_col = 'TradeID'
    else:
        sort_col = display_cols[0]
    df_display = df_filtered[display_cols].sort_values(sort_col, ascending=False).copy()
    
    # Add Delete checkbox column as first column
    df_display.insert(0, "Delete", False)
    
    edited = st.data_editor(
        df_display,
        use_container_width=True,
        hide_index=True,
        column_config={"Delete": st.column_config.CheckboxColumn("Delete", help="Select to delete this row from the Data Table")},
        disabled=[c for c in df_display.columns if c != "Delete"],
        key="all_positions_delete_editor",
    )
    
    # Get selected TradeIDs (where Delete is True)
    selected_mask = edited["Delete"] == True  # noqa: E712
    trade_ids_to_delete = edited.loc[selected_mask, "TradeID"].astype(str).str.strip().unique().tolist() if selected_mask.any() else []
    
    if trade_ids_to_delete:
        st.warning(f"Selected {len(trade_ids_to_delete)} position(s) to delete: {', '.join(trade_ids_to_delete[:10])}{' ...' if len(trade_ids_to_delete) > 10 else ''}")
        confirm = st.checkbox(
            "I understand these rows will be permanently removed from the Data Table (Excel)",
            value=False,
            key="all_pos_confirm_delete",
        )
        if st.button("üóëÔ∏è Delete selected position(s)", type="primary", use_container_width=True, key="all_pos_btn_delete", disabled=not confirm):
            try:
                data_file = str(st.session_state.get("current_data_file", ""))
                if not data_file:
                    st.error("No data file selected. Switch portfolio and try again.")
                else:
                    handler = ExcelHandler(data_file)
                    handler.delete_trades(trade_ids_to_delete)
                    refresh_data()
                    st.toast("Position(s) deleted.", icon="‚úÖ")
                    st.success(f"Deleted: {', '.join(trade_ids_to_delete[:15])}{' ...' if len(trade_ids_to_delete) > 15 else ''}")
                    st.rerun()
            except Exception as e:
                st.error(f"Delete failed: {e}")
    
    # Export button
    st.divider()
    csv = df_filtered[display_cols].to_csv(index=False)
    st.download_button("üì• Export to CSV", csv, "income_wheel_export.csv", "text/csv", key="export_all_positions")


# ============================================================
# MARGIN CONFIGURATION PAGE
# ============================================================
def render_margin_config():
    """Render margin configuration page - simple form by ticker and trade type"""
    st.title("‚öôÔ∏è Margin Configuration")
    
    # Initialize session state (load from persistence) - ALWAYS load to ensure persistence
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    st.session_state.margin_percentages = get_margin_percentages(portfolio)
    st.session_state.capital_allocation = get_capital_allocation(portfolio)
    st.session_state.portfolio_deposit = get_portfolio_deposit(portfolio)
    
    # Load open positions for PMCC configuration
    df_open = st.session_state.get('df_open', pd.DataFrame())
    
    # Load SGD and FX rate from persistence
    if 'portfolio_deposit_sgd' not in st.session_state:
        st.session_state.portfolio_deposit_sgd = get_portfolio_deposit_sgd(portfolio)
    if 'sgd_usd_fx_rate' not in st.session_state:
        st.session_state.sgd_usd_fx_rate = get_fx_rate(portfolio)
    
    # Refresh button
    col1, col2 = st.columns([1, 4])
    with col1:
        if st.button("üîÑ Refresh Data", type="primary", use_container_width=True):
            refresh_data()
            st.rerun()
    
    st.divider()
    
    # Ticker list for this portfolio (Income Wheel and Active Core each have their own)
    st.subheader("üìã Ticker List (Entry Forms Dropdown)")
    st.caption("Tickers you add here appear in the CC/CSP ticker dropdown in Entry Forms. Tickers from your current positions are always included. Income Wheel and Active Core have separate lists.")
    saved_tickers = get_tickers(portfolio)
    if not saved_tickers and portfolio == "Income Wheel":
        st.info("No custom tickers saved for this portfolio. Entry Forms use config default + positions. Add tickers below to build your list.")
    df_open_margin = st.session_state.get('df_open', pd.DataFrame())
    df_trades_margin = st.session_state.get('df_trades', pd.DataFrame())
    position_tickers = []
    if df_trades_margin is not None and not df_trades_margin.empty and 'Ticker' in df_trades_margin.columns:
        position_tickers = sorted(set(df_trades_margin['Ticker'].dropna().astype(str).str.strip().str.upper().unique().tolist()))
    full_list = get_tickers_for_dropdown(portfolio, df_trades_margin)
    
    add_col, _ = st.columns([1, 3])
    with add_col:
        new_ticker = st.text_input("Add ticker", key="margin_config_new_ticker", placeholder="e.g. AAPL").strip().upper()
        if st.button("‚ûï Add ticker", key="margin_config_add_ticker"):
            if new_ticker:
                updated = sorted(set(saved_tickers + [new_ticker]))
                save_tickers(updated, portfolio)
                st.toast(f"Added {new_ticker}", icon="‚úÖ")
                st.rerun()
            else:
                st.warning("Enter a ticker symbol.")
    
    if saved_tickers:
        st.markdown("**Saved tickers (remove to drop from list):**")
        for t in saved_tickers:
            c1, c2 = st.columns([3, 1])
            with c1:
                st.text(t)
            with c2:
                if st.button("Remove", key=f"margin_remove_ticker_{t}"):
                    updated = [x for x in saved_tickers if x != t]
                    save_tickers(updated, portfolio)
                    st.toast(f"Removed {t}", icon="‚úÖ")
                    st.rerun()
    if position_tickers and full_list:
        st.caption(f"Tickers from positions (always in dropdown): {', '.join(position_tickers)}")
    
    st.divider()
    
    # Portfolio Deposit Section
    st.subheader("üí∞ Portfolio Deposit")
    st.write("Enter portfolio deposit in SGD and FX rate. USD amount is auto-calculated for capital calculations.")
    
    # Load SGD and FX rate from persistence (already loaded above, but ensure they're set)
    if 'portfolio_deposit_sgd' not in st.session_state:
        st.session_state.portfolio_deposit_sgd = get_portfolio_deposit_sgd(portfolio)
    if 'sgd_usd_fx_rate' not in st.session_state:
        st.session_state.sgd_usd_fx_rate = get_fx_rate(portfolio)
    
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        portfolio_deposit_sgd = st.number_input(
            "Portfolio Deposit (SGD)", 
            min_value=0.0, 
            value=float(st.session_state.portfolio_deposit_sgd),
            step=1000.0,
            help="Total cash deposited in portfolio in SGD",
            key="portfolio_deposit_sgd_input"
        )
    
    with col2:
        sgd_usd_fx_rate = st.number_input(
            "SGD/USD FX Rate", 
            min_value=0.01, 
            value=float(st.session_state.sgd_usd_fx_rate),
            step=0.01,
            format="%.4f",
            help="Exchange rate: 1 USD = X SGD (e.g., 1.35 means 1 USD = 1.35 SGD)",
            key="sgd_usd_fx_rate_input"
        )
    
    # Calculate USD amount: USD = SGD / FX_RATE
    # If FX rate is 1.35, it means 1 USD = 1.35 SGD, so USD = SGD / 1.35
    portfolio_deposit_usd = portfolio_deposit_sgd / sgd_usd_fx_rate if sgd_usd_fx_rate > 0 else 0.0
    
    with col3:
        st.metric("Portfolio Deposit (USD)", f"${portfolio_deposit_usd:,.0f}", 
                  help="Auto-calculated: SGD √∑ FX Rate. This USD amount is used for all capital calculations.")
    
    # Save if values changed
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    if portfolio_deposit_sgd != st.session_state.portfolio_deposit_sgd:
        st.session_state.portfolio_deposit_sgd = portfolio_deposit_sgd
        save_portfolio_deposit_sgd(portfolio_deposit_sgd, portfolio)
    
    if sgd_usd_fx_rate != st.session_state.sgd_usd_fx_rate:
        st.session_state.sgd_usd_fx_rate = sgd_usd_fx_rate
        save_fx_rate(sgd_usd_fx_rate, portfolio)
    
    # Always save USD amount (recalculated)
    if portfolio_deposit_usd != st.session_state.portfolio_deposit:
        st.session_state.portfolio_deposit = portfolio_deposit_usd
        save_portfolio_deposit(portfolio_deposit_usd, portfolio)
        st.toast("Portfolio deposit saved.", icon="‚úÖ")
        st.success("‚úÖ Portfolio deposit saved!")
    
    st.divider()
    
    # Capital Allocation Section
    st.subheader("üíµ Capital Allocation by Counter")
    st.write("Enter percentage allocation for each counter (ticker). Capital allocated in $ is auto-calculated from portfolio deposit. You can add or remove counters.")
    
    # Ensure capital allocation is loaded from persistence (refresh on each page load)
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    st.session_state.capital_allocation = get_capital_allocation(portfolio)
    capital_allocation = st.session_state.capital_allocation.copy()
    
    # Get portfolio deposit for calculation
    portfolio_deposit = st.session_state.portfolio_deposit
    
    # Get all unique tickers from open positions
    df_open = st.session_state.df_open
    if df_open is not None and not df_open.empty:
        existing_tickers = sorted(df_open['Ticker'].unique().tolist())
    else:
        existing_tickers = []
    
    # Add existing tickers to allocation if not present
    for ticker in existing_tickers:
        if ticker not in capital_allocation:
            capital_allocation[ticker] = 0.0
    
    # Calculate percentages from current allocations
    allocation_percentages = {}
    for ticker, capital in capital_allocation.items():
        if portfolio_deposit > 0:
            allocation_percentages[ticker] = (capital / portfolio_deposit) * 100
        else:
            allocation_percentages[ticker] = 0.0
    
    # Display current allocations
    allocation_data = []
    for ticker in sorted(capital_allocation.keys()):
        pct = allocation_percentages.get(ticker, 0.0)
        capital = capital_allocation.get(ticker, 0.0)
        allocation_data.append({
            'Ticker': ticker,
            'Allocation %': pct,
            'Capital Allocated ($)': capital
        })
    
    if allocation_data:
        df_allocation = pd.DataFrame(allocation_data)
        
        # Editable table
        edited_allocation = st.data_editor(
            df_allocation,
            column_config={
                "Ticker": st.column_config.TextColumn("Ticker", width="small"),
                "Allocation %": st.column_config.NumberColumn(
                    "Allocation %",
                    min_value=0.0,
                    max_value=100.0,
                    step=0.1,
                    format="%.1f%%",
                    help="Enter percentage allocation for this counter"
                ),
                "Capital Allocated ($)": st.column_config.NumberColumn(
                    "Capital Allocated ($)",
                    min_value=0.0,
                    step=1000.0,
                    format="$%d",
                    help="Auto-calculated from percentage √ó portfolio deposit. You can manually override this value."
                )
            },
            hide_index=True,
            use_container_width=True,
            key="capital_allocation_table",
            num_rows="dynamic"  # Allow adding/removing rows
        )
        
        # Auto-update capital allocated when percentage changes
        # Store previous values to detect changes
        if 'prev_allocation_pct' not in st.session_state:
            st.session_state.prev_allocation_pct = allocation_percentages.copy()
        
        # Update capital based on percentage changes
        updated_df = edited_allocation.copy()
        for idx, row in updated_df.iterrows():
            ticker = str(row['Ticker']).strip().upper()
            if ticker:
                pct = float(row['Allocation %'])
                calculated_capital = (pct / 100.0) * portfolio_deposit if portfolio_deposit > 0 else 0.0
                current_capital = float(row['Capital Allocated ($)'])
                
                # Check if percentage changed from previous value
                prev_pct = st.session_state.prev_allocation_pct.get(ticker, 0.0)
                
                # If percentage changed, update capital to calculated value
                if abs(pct - prev_pct) > 0.01:  # Percentage changed
                    updated_df.at[idx, 'Capital Allocated ($)'] = calculated_capital
                # If capital was manually edited (doesn't match calculated from current %), keep it
                elif abs(current_capital - calculated_capital) > 10.0:  # User manually overrode
                    # Keep the manually entered value
                    pass
                else:
                    # Update to match current percentage (in case portfolio deposit changed)
                    updated_df.at[idx, 'Capital Allocated ($)'] = calculated_capital
        
        # Update session state with new percentages
        new_allocation_pct = {}
        for _, row in updated_df.iterrows():
            ticker = str(row['Ticker']).strip().upper()
            if ticker:
                new_allocation_pct[ticker] = float(row['Allocation %'])
        st.session_state.prev_allocation_pct = new_allocation_pct
        
        # Update capital allocation from edited table
        updated_allocation = {}
        for _, row in updated_df.iterrows():
            ticker = str(row['Ticker']).strip().upper()
            if ticker:
                updated_allocation[ticker] = float(row['Capital Allocated ($)'])
        
        if updated_allocation != capital_allocation:
            st.session_state.capital_allocation = updated_allocation
            portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
            save_capital_allocation(updated_allocation, portfolio)
            st.toast("Capital allocation saved.", icon="‚úÖ")
            st.success("‚úÖ Capital allocation saved!")
        
        # Show auto-calculation info
        if portfolio_deposit > 0:
            total_pct = updated_df['Allocation %'].sum()
            if total_pct > 100.0:
                st.warning(f"‚ö†Ô∏è Total allocation percentage is {total_pct:.1f}% (exceeds 100%)")
            elif total_pct < 100.0:
                st.info(f"‚ÑπÔ∏è Total allocation percentage is {total_pct:.1f}% (remaining: {100.0 - total_pct:.1f}%)")
    
    st.divider()
    
    # PMCC Configuration Section
    st.subheader("üîÑ PMCC Configuration")
    st.write("Mark tickers that use PMCC (Poor Man's Covered Call) logic. These will be excluded from CSP Tank calculations.")
    
    # Get current PMCC tickers
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    pmcc_tickers = get_pmcc_tickers(portfolio)
    pmcc_tickers_set = set(pmcc_tickers) if pmcc_tickers else set()
    
    # Get all unique tickers from open positions
    if not df_open.empty:
        all_tickers = sorted(set(df_open['Ticker'].unique()))
    else:
        all_tickers = []
    
    if all_tickers:
        # Create checkboxes for each ticker
        pmcc_checkboxes = {}
        cols = st.columns(min(4, len(all_tickers)))  # Max 4 columns
        
        for idx, ticker in enumerate(all_tickers):
            col_idx = idx % 4
            with cols[col_idx]:
                pmcc_checkboxes[ticker] = st.checkbox(
                    f"**{ticker}**",
                    value=ticker in pmcc_tickers_set,
                    key=f"pmcc_{ticker}",
                    help=f"Mark {ticker} as using PMCC logic"
                )
        
        # Save PMCC flags
        new_pmcc_tickers = {ticker for ticker, checked in pmcc_checkboxes.items() if checked}
        if new_pmcc_tickers != pmcc_tickers_set:
            save_pmcc_tickers(new_pmcc_tickers, portfolio)
            st.toast("PMCC configuration saved.", icon="‚úÖ")
            st.success("‚úÖ PMCC configuration saved!")
            st.rerun()
        
        if pmcc_tickers_set:
            st.info(f"‚ÑπÔ∏è **PMCC Tickers:** {', '.join(sorted(pmcc_tickers_set))} - These use separate PMCC logic (to be provided later)")
    else:
        st.info("‚ÑπÔ∏è No open positions found. PMCC configuration will be available once you have open positions.")
    
    st.divider()
    
    # Margin Configuration Section
    st.subheader("üìä Margin Percentage by Counter & Type")
    st.write("Enter margin percentage for each counter (ticker) and trade type. Query from your broker.")
    st.info("‚ÑπÔ∏è **Note:** Regular CCs (covered by stock) do NOT incur margin - set margin % to 0%. PMCC CCs (LEAP + CC) require capital and margin - set appropriate margin %.")
    
    if df_open is None or df_open.empty:
        st.warning("No open positions found.")
        return
    
    if df_open is None or df_open.empty:
        st.warning("No open positions found.")
        return
    
    # Get live prices for capital calculation (Yahoo Finance - always available)
    tickers = df_open['Ticker'].unique().tolist()
    live_prices = {}
    try:
        live_prices = get_cached_prices(tuple(tickers))
        st.session_state.live_prices = live_prices
        if live_prices:
            prices_available = sum(1 for p in live_prices.values() if p is not None)
            st.info(f"üìä Prices available for {prices_available}/{len(tickers)} tickers (Yahoo Finance, 10-15 min delay)")
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Could not fetch prices: {e}")
        live_prices = st.session_state.get('live_prices', {})
    
    # Ensure margin percentages are loaded from persistence (refresh on each page load)
    st.session_state.margin_percentages = get_margin_percentages()
    
    # Get unique ticker/type combinations
    ticker_types = df_open.groupby(['Ticker', 'TradeType']).size().reset_index()[['Ticker', 'TradeType']]
    
    # Calculate capital for each ticker/type combo
    margin_data = []
    for _, row in ticker_types.iterrows():
        ticker = row['Ticker']
        trade_type = row['TradeType']
        ticker_type_key = f"{ticker}_{trade_type}"
        
        # Calculate total capital for this ticker/type
        positions = df_open[(df_open['Ticker'] == ticker) & (df_open['TradeType'] == trade_type)]
        total_capital = 0.0
        
        for _, pos in positions.iterrows():
            if trade_type == 'CSP':
                strike = pd.to_numeric(pos.get('Option_Strike_Price_(USD)', 0), errors='coerce') or 0
                qty = pd.to_numeric(pos.get('Quantity', 0), errors='coerce') or 0
                total_capital += strike * 100 * qty
            elif trade_type == 'LEAP':
                # LEAP capital = contract premium paid (OptPremium √ó Quantity)
                # OptPremium is the total premium per contract (not per share), so we don't multiply by 100
                premium = pd.to_numeric(pos.get('OptPremium', 0), errors='coerce') or 0
                qty = pd.to_numeric(pos.get('Quantity', 0), errors='coerce') or 0
                # Use absolute value for quantity (long positions)
                if 'Direction' in pos and pos.get('Direction') == 'Buy':
                    qty = abs(qty)
                total_capital += premium * qty
            elif trade_type == 'STOCK':
                if 'Open_lots' in pos and pd.notna(pos['Open_lots']):
                    shares = abs(pd.to_numeric(pos['Open_lots'], errors='coerce') or 0)
                else:
                    qty = pd.to_numeric(pos.get('Quantity', 0), errors='coerce') or 0
                    shares = abs(qty) * 100
                # Use live prices as fallback
                price = pd.to_numeric(pos.get('Price_of_current_underlying_(USD)', 0), errors='coerce')
                if pd.isna(price) or price == 0:
                    if ticker in live_prices and live_prices[ticker] is not None:
                        price = live_prices[ticker]
                    else:
                        price = 0.0
                total_capital += price * shares
        
        # Get current margin %
        current_margin_pct = st.session_state.margin_percentages.get(ticker_type_key, 0.0)
        
        margin_data.append({
            'Ticker': ticker,
            'Type': trade_type,
            'Capital ($)': total_capital,
            'Margin %': current_margin_pct,
            'Margin Used ($)': total_capital * (current_margin_pct / 100.0)
        })
    
    df_margin = pd.DataFrame(margin_data)
    df_margin = df_margin.sort_values(['Ticker', 'Type'])
    
    # Check for positions with $0 capital (missing prices)
    zero_capital = df_margin[df_margin['Capital ($)'] == 0]
    if len(zero_capital) > 0 and not live_prices:
        st.warning(f"‚ö†Ô∏è {len(zero_capital)} ticker/type combinations show $0 capital due to missing prices. Prices will be fetched from Yahoo Finance, or update prices in Excel.")
    
    # Create editable form
    edited_df = st.data_editor(
        df_margin,
        column_config={
            "Ticker": st.column_config.TextColumn("Ticker", disabled=True),
            "Type": st.column_config.TextColumn("Type", disabled=True),
            "Capital ($)": st.column_config.NumberColumn("Capital ($)", format="$%d", disabled=True),
            "Margin %": st.column_config.NumberColumn(
                "Margin % (from broker)",
                help="Enter margin percentage from your broker.",
                min_value=0.0,
                max_value=100.0,
                step=0.1,
                format="%.1f%%"
            ),
            "Margin Used ($)": st.column_config.NumberColumn("Margin Used ($)", format="$%d", disabled=True)
        },
        hide_index=True,
        use_container_width=True,
        key="margin_config_table"
    )
    
    # Recalculate margin used after editing
    edited_df['Margin Used ($)'] = edited_df['Capital ($)'] * (edited_df['Margin %'] / 100.0)
    
    # Update session state (no autocorrection)
    updated_margin_percentages = {}
    for _, row in edited_df.iterrows():
        ticker = row['Ticker']
        trade_type = row['Type']
        ticker_type_key = f"{ticker}_{trade_type}"
        updated_margin_percentages[ticker_type_key] = float(row['Margin %'])
    
    st.session_state.margin_percentages = updated_margin_percentages
    portfolio = st.session_state.get('current_portfolio', 'Income Wheel')
    save_margin_percentages(updated_margin_percentages, portfolio)  # Persist to file
    
    st.toast("Margin percentages saved.", icon="‚úÖ")
    st.success("‚úÖ Margin percentages saved! Return to Dashboard to see updated calculations.")


# ============================================================
# MAIN
# ============================================================
def main():
    """Main application entry point"""
    init_session_state()
    
    # Render sidebar and get selected page and portfolio
    page, portfolio = render_sidebar()
    
    # Get portfolio name (without emoji for data loading)
    portfolio_name = "Active Core" if portfolio == "‚≠ê Active Core" else "Income Wheel"
    
    # Load data for selected portfolio
    df_trades, df_audit, errors = load_data(portfolio_name)
    
    if errors and df_trades is None:
        data_file = get_data_file(portfolio_name)
        st.error(f"‚ùå {errors[0]}")
        if not data_file.exists():
            st.info(f"üí° **File not found**: `{data_file.name}`\n\n"
                   f"For **{portfolio_name}**, the app expects a file named `{data_file.name}` in the `data` folder.\n\n"
                   f"**Options:**\n"
                   f"1. Create a new Excel file with the same schema as `income_wheel_data.xlsx`\n"
                   f"2. Copy `income_wheel_data.xlsx` and rename it to `{data_file.name}`\n"
                   f"3. Run `python migrate_data.py` to initialize the data file (if you have migration data)")
        else:
            st.info("Run `python migrate_data.py` to initialize the data file.")
        return
    
    # Store in session
    st.session_state.df_trades = df_trades
    st.session_state.df_audit = df_audit
    st.session_state.df_open = df_trades[df_trades['Status'] == 'Open'] if df_trades is not None else None
    st.session_state.data_loaded = True
    st.session_state.current_portfolio = portfolio_name
    st.session_state.current_data_file = get_data_file(portfolio_name)
    st.session_state.portfolio_deposit = get_portfolio_deposit(portfolio_name)
    st.session_state.margin_percentages = get_margin_percentages(portfolio_name)

    # Show confirmation after form submit (so user sees it after rerun and fresh data)
    if st.session_state.get('success_message'):
        msg = st.session_state.success_message
        st.toast(msg, icon="‚úÖ")
        st.success(msg)
        del st.session_state.success_message

    # Show data integrity warnings only for this portfolio (skip "Audit references missing trades" for Active Core when audit has other portfolio's IDs)
    if errors:
        for err in errors:
            if "Audit references missing trades" in err and portfolio_name == "Active Core":
                continue
            st.warning(f"‚ö†Ô∏è Data integrity warning: {err}")
    
    # Render selected page (all pages work for both portfolios)
    if page == "üìä Dashboard":
        render_dashboard()
    elif page == "üìã CIO Report":
        render_daily_report_panel()
    elif page == "üìÖ Daily Helper":
        render_daily_helper()
    elif page == "üìù Entry Forms":
        render_entry_forms()
    elif page == "üìà Expiry Ladder":
        render_expiry_ladder()
    elif page == "üìä Performance":
        render_performance()
    elif page == "üìã All Positions":
        render_all_positions()
    elif page == "‚öôÔ∏è Margin Config":
        render_margin_config()
    elif page == "üìö Strategy Instructions":
        render_strategy_instructions()
    elif page == "üîç Income Scanner":
        render_income_scanner()
    elif page == "üì° Market Data":
        render_market_data_panel()


def render_market_data_panel():
    """
    Standalone Market Data query panel (Mode 2B).
    Allows user to query equity prices, options data, and historical OHLCV
    independently of the live positions feed.
    """
    st.header("üì° Market Data")
    st.caption("Query live prices, options data, and historical OHLCV ‚Äî powered by yfinance, Alpaca, and Stooq.")

    tab_equity, tab_options, tab_history = st.tabs(["Equity Quote", "Options Chain", "Historical OHLCV"])

    # ------------------------------------------------------------------
    # Tab 1 ‚Äî Equity Quote
    # ------------------------------------------------------------------
    with tab_equity:
        st.subheader("Live Equity Quote")
        ticker_input = st.text_input("Ticker symbol", placeholder="e.g. MARA, SPY", key="md_equity_ticker").upper().strip()
        if st.button("Get Quote", key="md_equity_btn") and ticker_input:
            with st.spinner(f"Fetching {ticker_input}..."):
                quotes = _market_data.get_equity_prices([ticker_input])
            if ticker_input in quotes:
                q = quotes[ticker_input]
                c1, c2, c3 = st.columns(3)
                c1.metric("Price", f"${q.price:.2f}")
                c2.metric("Prev Close", f"${q.prev_close:.2f}")
                change_pct = ((q.price - q.prev_close) / q.prev_close * 100) if q.prev_close else 0
                c3.metric("Change", f"{change_pct:+.2f}%")
                st.caption(f"As of {q.timestamp.strftime('%Y-%m-%d %H:%M:%S')} (15-min delay)")
            else:
                st.warning(f"Could not retrieve price for {ticker_input}.")

    # ------------------------------------------------------------------
    # Tab 2 ‚Äî Options Chain
    # ------------------------------------------------------------------
    with tab_options:
        st.subheader("Open Positions ‚Äî Options Data")
        st.caption("Shows bid/ask/last/IV and Greeks for your current open CC and CSP positions.")

        alpaca_ok = _market_data.alpaca_available
        if not alpaca_ok:
            st.info("Greeks (Œî Œì Œò) are unavailable ‚Äî add ALPACA_API_KEY and ALPACA_SECRET_KEY to .env to enable.")

        if st.button("Refresh Options Data", key="md_options_btn"):
            try:
                df_trades = st.session_state.get("df_trades")
                if df_trades is not None and not df_trades.empty:
                    df_open = df_trades[
                        (df_trades["Status"] == "Open") &
                        (df_trades["TradeType"].isin(["CC", "CSP"]))
                    ].copy()
                    with st.spinner("Fetching options data..."):
                        contracts = _market_data.get_open_positions_data(df_open)
                    st.session_state.open_positions_data = contracts
                else:
                    st.warning("No trade data loaded.")
            except Exception as exc:
                st.error(f"Error fetching options data: {exc}")

        contracts = st.session_state.get("open_positions_data", [])
        if contracts:
            rows = []
            for c in contracts:
                rows.append({
                    "Contract": c.contract_symbol,
                    "Underlying": c.underlying,
                    "Strike": c.strike,
                    "Expiry": str(c.expiry),
                    "Type": "Call" if c.right == "C" else "Put",
                    "Bid": f"${c.bid:.2f}",
                    "Ask": f"${c.ask:.2f}",
                    "Last": f"${c.last_price:.2f}",
                    "IV": f"{c.implied_volatility:.1%}" if c.implied_volatility else "‚Äî",
                    "Œî Delta": f"{c.delta:.3f}" if c.delta is not None else "‚Äî",
                    "Œì Gamma": f"{c.gamma:.4f}" if c.gamma is not None else "‚Äî",
                    "Œò Theta": f"{c.theta:.3f}" if c.theta is not None else "‚Äî",
                })
            st.dataframe(pd.DataFrame(rows), use_container_width=True, hide_index=True)
        else:
            st.info("Click 'Refresh Options Data' to load current positions.")

    # ------------------------------------------------------------------
    # Tab 3 ‚Äî Historical OHLCV
    # ------------------------------------------------------------------
    with tab_history:
        st.subheader("Historical OHLCV")
        col1, col2, col3 = st.columns([2, 1, 1])
        with col1:
            hist_ticker = st.text_input("Ticker", placeholder="e.g. MARA, SPY", key="md_hist_ticker").upper().strip()
        with col2:
            period = st.selectbox("Period", [30, 60, 90, 180, 365], index=2, key="md_hist_period")
        with col3:
            freq = st.selectbox("Frequency", ["daily", "monthly"], key="md_hist_freq")

        if st.button("Get History", key="md_hist_btn") and hist_ticker:
            with st.spinner(f"Fetching {hist_ticker} {freq} data ({period} days)..."):
                bars = _market_data.get_historical_ohlcv(hist_ticker, period_days=period, frequency=freq)

            if bars:
                import plotly.graph_objects as go
                df_bars = pd.DataFrame([
                    {"Date": b.date, "Open": b.open, "High": b.high,
                     "Low": b.low, "Close": b.close, "Volume": b.volume}
                    for b in bars
                ])
                fig = go.Figure(data=[go.Candlestick(
                    x=df_bars["Date"], open=df_bars["Open"],
                    high=df_bars["High"], low=df_bars["Low"], close=df_bars["Close"]
                )])
                fig.update_layout(
                    title=f"{hist_ticker} ‚Äî {freq.title()} OHLCV",
                    xaxis_title="Date", yaxis_title="Price (USD)",
                    xaxis_rangeslider_visible=False, height=400
                )
                st.plotly_chart(fig, use_container_width=True)
                st.dataframe(df_bars, use_container_width=True, hide_index=True)
            else:
                st.warning(f"No data returned for {hist_ticker}. Check ticker symbol.")


if __name__ == "__main__":
    main()
